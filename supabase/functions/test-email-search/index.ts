import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.45.0";

const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers": "authorization, x-client-info, x-client-version, apikey, content-type",
  "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS"
};

// Utilidades de sanitizaci√≥n para logs
const maskEmail = (email?: string) => {
  if (!email || typeof email !== 'string') return email;
  const [user, domain] = email.split('@');
  const visible = user.slice(0, 2);
  return `${visible}***@${domain}`;
};

const maskId = (id?: string) => {
  if (!id || typeof id !== 'string') return id;
  return `${id.slice(0, 6)}...`;
};

const logStep = (step: string, details?: unknown) => {
  try {
    const detailsStr = details ? ` - ${JSON.stringify(details)}` : '';
    console.log(`[TEST-EMAIL-SEARCH] ${step}${detailsStr}`);
  } catch {
    console.log(`[TEST-EMAIL-SEARCH] ${step}`);
  }
};

serve(async (req) => {
  if (req.method === "OPTIONS") {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    logStep("Funci√≥n de prueba iniciada");

    // Verificar variables de entorno
    const supabaseUrl = Deno.env.get("SUPABASE_URL");
    const supabaseServiceKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY");

    if (!supabaseUrl || !supabaseServiceKey) {
      logStep("ERROR - Variables de entorno faltantes");
      throw new Error("Variables de entorno requeridas no configuradas");
    }

    // Obtener datos del request
    const { test_email } = await req.json();

    if (!test_email) {
      logStep("ERROR - Par√°metro test_email faltante");
      throw new Error("Se requiere test_email");
    }

    logStep("Email a probar", { test_email: maskEmail(test_email) });

    // Inicializar Supabase con service role
    const supabase = createClient(supabaseUrl, supabaseServiceKey, {
      auth: { persistSession: false }
    });

    // ‚úÖ PRUEBA 1: L√ìGICA ACTUAL DEL WEBHOOK (PROBLEM√ÅTICA)
    logStep("=== PRUEBA 1: L√ìGICA ACTUAL DEL WEBHOOK (PROBLEM√ÅTICA) ===");
    
    try {
      logStep("Llamando a supabase.auth.admin.listUsers()");
      const { data: existingUsers, error: userCheckError } = await supabase.auth.admin.listUsers();
      
      if (userCheckError) {
        logStep("ERROR en listUsers", { error: userCheckError.message });
        throw userCheckError;
      }

      logStep("listUsers exitoso", { 
        totalUsers: existingUsers.users.length,
        testEmail: maskEmail(test_email)
      });

      // Buscar usuario por email (igual que en el webhook actual)
      const foundUser = existingUsers.users.find(user => 
        user.email?.toLowerCase() === test_email.toLowerCase()
      );

      if (foundUser) {
        logStep("‚úÖ Usuario encontrado con listUsers", { 
          userId: maskId(foundUser.id),
          email: maskEmail(foundUser.email),
          emailConfirmed: foundUser.email_confirmed_at ? 'yes' : 'no',
          createdAt: foundUser.created_at
        });
      } else {
        logStep("‚ùå Usuario NO encontrado con listUsers", { 
          testEmail: maskEmail(test_email),
          totalUsersChecked: existingUsers.users.length
        });
      }

    } catch (error) {
      logStep("ERROR en PRUEBA 1", { error: error instanceof Error ? error.message : String(error) });
    }

    // ‚úÖ PRUEBA 2: L√ìGICA ANTERIOR QUE FUNCIONABA (SOLUCI√ìN)
    logStep("=== PRUEBA 2: L√ìGICA ANTERIOR QUE FUNCIONABA (SOLUCI√ìN) ===");
    
    try {
      logStep("Usando m√©todo anterior que funcionaba");
      
      // ‚úÖ M√âTODO CORREGIDO: Obtener usuarios y buscar manualmente
      const { data: { users }, error: listUsersError } = await supabase.auth.admin.listUsers();

      if (listUsersError) {
        logStep("ERROR en listUsers (m√©todo anterior)", { error: listUsersError.message });
        throw listUsersError;
      }
      
      logStep("listUsers exitoso (m√©todo anterior)", { 
        totalUsers: users.length,
        testEmail: maskEmail(test_email)
      });

      // ‚úÖ B√öSQUEDA MANUAL: Encontrar usuario exacto por email
      const existingUser = users.find(user => user.email === test_email);

      if (existingUser) {
        logStep("‚úÖ Usuario encontrado con l√≥gica anterior", { 
          userId: maskId(existingUser.id),
          email: maskEmail(existingUser.email),
          emailConfirmed: existingUser.email_confirmed_at ? 'yes' : 'no',
          createdAt: existingUser.created_at
        });
      } else {
        logStep("‚ùå Usuario NO encontrado con l√≥gica anterior", { 
          testEmail: maskEmail(test_email),
          totalUsersChecked: users.length
        });
      }

    } catch (error) {
      logStep("ERROR en PRUEBA 2", { error: error instanceof Error ? error.message : String(error) });
    }

    // ‚úÖ PRUEBA 3: NUEVA L√ìGICA PROPUESTA (TABLA PROFILES)
    logStep("=== PRUEBA 3: NUEVA L√ìGICA PROPUESTA (TABLA PROFILES) ===");
    
    try {
      logStep("Buscando usuario en tabla profiles (nueva l√≥gica)");
      const { data: existingUser, error: userCheckError } = await supabase
        .from('profiles')
        .select('id, email, role, created_at')
        .eq('email', test_email)
        .single();

      if (userCheckError) {
        if (userCheckError.code === 'PGRST116') {
          logStep("‚ùå Usuario NO encontrado con nueva l√≥gica", { 
            testEmail: maskEmail(test_email),
            error: 'No rows returned'
          });
        } else {
          logStep("ERROR en nueva l√≥gica", { error: userCheckError.message });
        }
      } else {
        logStep("‚úÖ Usuario encontrado con nueva l√≥gica", { 
          userId: maskId(existingUser.id),
          email: maskEmail(existingUser.email),
          role: existingUser.role,
          createdAt: existingUser.created_at
        });
      }

    } catch (error) {
      logStep("ERROR en PRUEBA 3", { error: error instanceof Error ? error.message : String(error) });
    }

    // ‚úÖ PRUEBA 4: COMPARACI√ìN DE LOS TRES M√âTODOS
    logStep("=== PRUEBA 4: COMPARACI√ìN DE LOS TRES M√âTODOS ===");
    
    try {
      // M√©todo 1: L√≥gica actual (problem√°tica)
      const { data: currentUsers, error: currentError } = await supabase.auth.admin.listUsers();
      let currentFound = false;
      let currentUserId = null;
      
      if (!currentError && currentUsers?.users) {
        const foundInCurrent = currentUsers.users.find(user => 
          user.email?.toLowerCase() === test_email.toLowerCase()
        );
        if (foundInCurrent) {
          currentFound = true;
          currentUserId = foundInCurrent.id;
        }
      }

      // M√©todo 2: L√≥gica anterior (funcional)
      const { data: { users: oldUsers }, error: oldError } = await supabase.auth.admin.listUsers();
      let oldFound = false;
      let oldUserId = null;
      
      if (!oldError && oldUsers) {
        const foundInOld = oldUsers.find(user => user.email === test_email);
        if (foundInOld) {
          oldFound = true;
          oldUserId = foundInOld.id;
        }
      }

      // M√©todo 3: Tabla profiles
      const { data: profilesResult, error: profilesError } = await supabase
        .from('profiles')
        .select('id, email, role')
        .eq('email', test_email)
        .single();
      
      let profilesFound = false;
      let profilesUserId = null;
      
      if (!profilesError && profilesResult) {
        profilesFound = true;
        profilesUserId = profilesResult.id;
      }

      // Comparar resultados
      logStep("Comparaci√≥n de los tres m√©todos", {
        testEmail: maskEmail(test_email),
        metodoActual: {
          encontrado: currentFound,
          userId: currentUserId ? maskId(currentUserId) : null
        },
        metodoAnterior: {
          encontrado: oldFound,
          userId: oldUserId ? maskId(oldUserId) : null
        },
        metodoProfiles: {
          encontrado: profilesFound,
          userId: profilesUserId ? maskId(profilesUserId) : null
        }
      });

      // An√°lisis de discrepancias
      if (currentFound !== oldFound) {
        logStep("‚ö†Ô∏è DISCREPANCIA: M√©todo actual vs M√©todo anterior", {
          actual: currentFound,
          anterior: oldFound,
          recomendacion: "El m√©todo anterior es m√°s confiable"
        });
      }

      if (oldFound !== profilesFound) {
        logStep("‚ö†Ô∏è DISCREPANCIA: M√©todo anterior vs Tabla profiles", {
          anterior: oldFound,
          profiles: profilesFound,
          recomendacion: "Verificar sincronizaci√≥n entre auth.users y profiles"
        });
      }

      // Recomendaci√≥n final
      if (oldFound && !currentFound) {
        logStep("üéØ RECOMENDACI√ìN FINAL", {
          problema: "M√©todo actual no encuentra usuarios que S√ç existen",
          solucion: "Usar m√©todo anterior (users.find(user => user.email === customerEmail))",
          razon: "M√°s directo y confiable"
        });
      }

    } catch (error) {
      logStep("ERROR en PRUEBA 4", { error: error instanceof Error ? error.message : String(error) });
    }

    // ‚úÖ PRUEBA 5: SIMULACI√ìN DEL FLUJO COMPLETO CON M√âTODO ANTERIOR
    logStep("=== PRUEBA 5: SIMULACI√ìN DEL FLUJO COMPLETO CON M√âTODO ANTERIOR ===");
    
    try {
      logStep("Simulando flujo del webhook con m√©todo anterior (funcional)");
      
      // Simular la l√≥gica que funcionaba en el webhook anterior
      const customerEmail = test_email;
      
      // ‚úÖ M√âTODO ANTERIOR: Obtener usuarios y buscar manualmente
      const { data: { users }, error: listUsersError } = await supabase.auth.admin.listUsers();

      if (listUsersError) {
        logStep("‚ùå FLUJO: Error al listar usuarios", { 
          error: listUsersError.message,
          email: maskEmail(customerEmail)
        });
      } else {
        // ‚úÖ B√öSQUEDA MANUAL: Encontrar usuario exacto por email
        const existingUser = users.find(user => user.email === customerEmail);

        if (existingUser) {
          logStep("‚úÖ FLUJO: Usuario existe, se debe vincular caso", { 
            userId: maskId(existingUser.id),
            email: maskEmail(existingUser.email),
            emailConfirmed: existingUser.email_confirmed_at ? 'yes' : 'no',
            accion: "Vincular caso a usuario existente"
          });
        } else {
          logStep("‚úÖ FLUJO: Usuario NO existe, se debe crear nuevo", { 
            email: maskEmail(customerEmail),
            accion: "Crear nuevo usuario"
          });
        }
      }

    } catch (error) {
      logStep("ERROR en PRUEBA 5", { error: error instanceof Error ? error.message : String(error) });
    }

    // ‚úÖ PRUEBA 6: VERIFICACI√ìN DE PERMISOS
    logStep("=== PRUEBA 6: VERIFICACI√ìN DE PERMISOS ===");
    
    try {
      logStep("Verificando permisos del service role");
      
      // Intentar obtener informaci√≥n b√°sica del sistema
      const { data: systemInfo, error: systemError } = await supabase
        .from('profiles')
        .select('count')
        .limit(1);

      if (systemError) {
        logStep("ERROR en verificaci√≥n de permisos", { error: systemError.message });
      } else {
        logStep("‚úÖ Permisos verificados correctamente", { 
          puedeAcceder: true,
          totalProfiles: systemInfo.length
        });
      }

    } catch (error) {
      logStep("ERROR en PRUEBA 6", { error: error instanceof Error ? error.message : String(error) });
    }

    logStep("=== RESUMEN DE PRUEBAS ===");
    logStep("Funci√≥n de prueba completada exitosamente");

    return new Response(JSON.stringify({ 
      success: true, 
      message: "Pruebas completadas",
      test_email: maskEmail(test_email),
      timestamp: new Date().toISOString()
    }), {
      headers: { ...corsHeaders, "Content-Type": "application/json" },
      status: 200,
    });

  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logStep("ERROR en funci√≥n de prueba", { message: errorMessage });
    
    return new Response(JSON.stringify({ 
      error: errorMessage,
      timestamp: new Date().toISOString()
    }), {
      status: 500,
      headers: { ...corsHeaders, "Content-Type": "application/json" },
    });
  }
});

{
  "master": {
    "tasks": [
      {
        "id": 3,
        "title": "Implement Complete Row Level Security (RLS)",
        "description": "Conduct a comprehensive audit of all database tables and implement strict RLS policies to ensure data access is properly restricted to authorized users only.",
        "details": "1. Create a script to identify all tables in the Supabase database\n2. For each table containing user data or sensitive information:\n   - Review existing RLS policies\n   - Create or update policies for SELECT, INSERT, UPDATE, DELETE operations\n   - Ensure policies follow the principle of least privilege\n3. Implement specific policies based on user roles:\n   - Regular users should only access their own data\n   - Lawyers should only access assigned cases\n   - Admins should have appropriate access controls\n4. Example policy for a user_profiles table:\n```sql\nCREATE POLICY \"Users can view their own profiles\"\nON user_profiles\nFOR SELECT\nUSING (auth.uid() = user_id);\n\nCREATE POLICY \"Users can update their own profiles\"\nON user_profiles\nFOR UPDATE\nUSING (auth.uid() = user_id);\n```\n5. Document all policies in a central security document",
        "testStrategy": "1. Create test cases for each table and policy\n2. Verify access control by attempting unauthorized operations:\n   - Try to access data belonging to other users\n   - Attempt to modify data without proper permissions\n3. Use Supabase's policy simulator to test policies\n4. Create automated tests that verify RLS is working correctly\n5. Document test results and any policy adjustments made",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Fix PostgreSQL Function Vulnerabilities",
        "description": "Address performance issues in Row Level Security (RLS) policies that have been identified as critical after the search_path vulnerabilities were resolved.",
        "status": "pending",
        "dependencies": [],
        "priority": "high",
        "details": "The original search_path vulnerabilities in the 13 PostgreSQL functions have been fixed. Now we need to focus on optimizing RLS policies:\n\n1. Run `supabase db lint` to identify any remaining issues and focus on RLS policy performance warnings\n2. Analyze each RLS policy for performance bottlenecks, particularly:\n   - Policies with complex joins\n   - Policies without proper indexing\n   - Policies with expensive functions\n3. Create a migration SQL file to optimize the identified RLS policies\n4. For each problematic policy, consider:\n   - Adding appropriate indexes\n   - Simplifying policy expressions\n   - Rewriting policies to use more efficient patterns\n5. Example optimization format:\n```sql\n-- Optimize RLS policy for table_name\nDROP POLICY IF EXISTS policy_name ON table_name;\nCREATE POLICY policy_name ON table_name\nFOR operation\nTO role\nUSING (optimized_expression);\n\n-- Add supporting index if needed\nCREATE INDEX IF NOT EXISTS idx_name ON table_name(columns);\n```\n6. Apply the migration to both local and cloud environments\n7. Document all changes made to the policies and their performance impact",
        "testStrategy": "1. Benchmark performance before and after policy changes\n2. Create test cases that specifically target the optimized policies\n3. Use EXPLAIN ANALYZE to verify query plans are using indexes properly\n4. Test with realistic data volumes to ensure optimizations are effective\n5. Monitor query performance in development environment before deploying to production\n6. Document performance improvements with metrics\n7. Include RLS policy performance checks in CI/CD pipeline",
        "subtasks": [
          {
            "id": 1,
            "title": "Document resolution of search_path vulnerabilities",
            "description": "Create documentation noting that the original 13 PostgreSQL functions with mutable search_path issues have been fixed. Include the list of functions that were affected and how they were resolved.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Identify problematic RLS policies",
            "description": "Run performance analysis to identify RLS policies causing performance issues. Create a prioritized list of policies that need optimization.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Create optimization plan for each policy",
            "description": "For each identified problematic policy, document the current implementation, performance issues, and proposed optimization approach.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement RLS policy optimizations",
            "description": "Create migration files with optimized RLS policies and supporting indexes.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Performance testing",
            "description": "Create and run benchmarks to measure performance improvements from the optimized policies.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 5,
        "title": "Implement Rate Limiting",
        "description": "Configure rate limiting on authentication endpoints and other critical API functions to protect against brute force attacks and API abuse.",
        "details": "1. Access Supabase dashboard and navigate to Authentication settings\n2. Configure rate limiting for the following operations:\n   - Login attempts (e.g., 5 attempts per minute)\n   - Password reset requests (e.g., 3 requests per hour)\n   - User registration (e.g., 3 registrations per hour per IP)\n   - API key usage (appropriate limits based on expected usage)\n3. For custom API endpoints, implement rate limiting using middleware:\n```javascript\n// Example using Express Rate Limit middleware\nconst rateLimit = require('express-rate-limit');\n\nconst authLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 5, // 5 requests per windowMs\n  message: 'Too many authentication attempts, please try again later'\n});\n\napp.use('/api/auth/', authLimiter);\n```\n4. Implement appropriate client-side handling of rate limit responses\n5. Add monitoring for rate limit events",
        "testStrategy": "1. Create automated tests that attempt to exceed rate limits\n2. Verify that rate limiting correctly blocks excessive requests\n3. Test client-side handling of rate limit responses\n4. Simulate various attack scenarios to ensure protection\n5. Monitor rate limit events in production to fine-tune limits as needed",
        "priority": "medium",
        "dependencies": [
          3,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Create Audit Trail System",
        "description": "Develop a comprehensive audit logging system to track security events, user actions, and data access for compliance with GDPR and security incident response.",
        "details": "1. Create a new `audit_log` table in Supabase:\n```sql\nCREATE TABLE audit_log (\n  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n  user_id UUID REFERENCES auth.users(id),\n  action TEXT NOT NULL,\n  table_name TEXT,\n  record_id TEXT,\n  old_data JSONB,\n  new_data JSONB,\n  ip_address TEXT,\n  user_agent TEXT,\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n);\n```\n2. Create PostgreSQL triggers for critical tables to automatically log changes:\n```sql\nCREATE OR REPLACE FUNCTION log_audit_event()\nRETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO audit_log (user_id, action, table_name, record_id, old_data, new_data)\n  VALUES (auth.uid(), TG_OP, TG_TABLE_NAME, NEW.id, \n          CASE WHEN TG_OP = 'DELETE' THEN to_jsonb(OLD) ELSE NULL END,\n          CASE WHEN TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN to_jsonb(NEW) ELSE NULL END);\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n```\n3. Apply triggers to relevant tables\n4. Implement frontend logging for authentication events:\n   - Login attempts (successful and failed)\n   - Password changes\n   - Profile updates\n   - Permission changes\n5. Create an admin interface to view and filter audit logs\n6. Implement GDPR-compliant data retention policies for logs",
        "testStrategy": "1. Test automatic logging by performing various database operations\n2. Verify that all required fields are properly captured\n3. Test authentication event logging\n4. Create test cases for each type of auditable action\n5. Verify that sensitive data is properly handled in logs\n6. Test the admin interface for viewing logs\n7. Verify that logs are retained according to policy",
        "priority": "medium",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Configure Leaked Password Protection",
        "description": "Enable Supabase's leaked password protection feature to check user passwords against known compromised password databases like HaveIBeenPwned.",
        "details": "1. Evaluate Supabase pricing plans that include leaked password protection\n2. Once upgraded to an appropriate plan:\n   - Access Supabase dashboard\n   - Navigate to Authentication settings\n   - Enable the 'Leaked Password Protection' feature\n3. Configure the feature to check passwords during:\n   - New user registration\n   - Password changes\n   - Password resets\n4. Implement appropriate error messages in the frontend:\n```javascript\n// Example React component handling leaked password error\nconst handleSignUp = async (email, password) => {\n  try {\n    const { error } = await supabase.auth.signUp({ email, password });\n    if (error) {\n      if (error.message.includes('leaked password')) {\n        setError('This password has been found in a data breach. Please choose a different password.');\n      } else {\n        setError(error.message);\n      }\n    }\n  } catch (error) {\n    setError('An unexpected error occurred');\n  }\n};\n```\n5. Document the feature in user documentation",
        "testStrategy": "1. Test with known compromised passwords to verify detection\n2. Verify that appropriate error messages are displayed\n3. Test password change and reset flows\n4. Ensure the feature doesn't block valid, secure passwords\n5. Monitor user feedback after implementation",
        "priority": "low",
        "dependencies": [
          3,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Plan External Security Audit",
        "description": "Prepare for and coordinate an external security audit (penetration testing) to identify potential vulnerabilities in the application once it reaches a mature state.",
        "details": "1. Research and evaluate security audit providers specializing in web applications and Supabase\n2. Create a comprehensive scope document for the audit, including:\n   - Authentication system\n   - Authorization and access controls\n   - API endpoints\n   - Database security\n   - Frontend security\n   - Infrastructure security\n3. Prepare a budget proposal with cost estimates from 3-5 providers\n4. Create a timeline for the audit process:\n   - Pre-audit preparation\n   - Audit execution (typically 1-2 weeks)\n   - Remediation period\n   - Re-testing\n5. Develop a security documentation package for auditors:\n   - System architecture\n   - Authentication flows\n   - Data models\n   - Security controls already in place\n6. Create a plan for addressing findings post-audit",
        "testStrategy": "1. Conduct an internal pre-audit using tools like OWASP ZAP\n2. Create a checklist of security best practices to verify before the external audit\n3. Develop a process for tracking and prioritizing audit findings\n4. Plan for verification testing after remediation\n5. Create a template for documenting audit results and actions taken",
        "priority": "low",
        "dependencies": [
          3,
          4,
          5,
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Optimize RLS Policies for Performance Improvement",
        "description": "Optimize 50+ Row Level Security (RLS) policies that are causing critical performance issues by refactoring auth function calls and consolidating duplicate policies.",
        "details": "1. Identify all RLS policies that are causing performance issues:\n   - Run `supabase db lint` to identify RLS policies with performance warnings\n   - Use `pg_stat_statements` to identify the slowest queries related to RLS policies\n   - Review all policies that call auth functions directly in the policy definition\n\n2. Refactor RLS policies to optimize auth function calls:\n   - Replace direct auth function calls in row-level evaluations with subqueries\n   - Example transformation:\n     ```sql\n     -- Before (inefficient - evaluates for each row)\n     CREATE POLICY \"Users can view their own data\" ON \"public\".\"profiles\"\n       USING (auth.uid() = user_id);\n       \n     -- After (optimized - evaluates once per query)\n     CREATE POLICY \"Users can view their own data\" ON \"public\".\"profiles\"\n       USING ((SELECT auth.uid()) = user_id);\n     ```\n\n3. Consolidate duplicate or overlapping policies:\n   - Identify tables with multiple similar policies that can be combined\n   - Create a spreadsheet to track all policies, their purpose, and consolidation opportunities\n   - Develop a migration plan that ensures no security gaps during transition\n\n4. Create database migration files:\n   - For each table with policies to optimize, create DROP and CREATE statements\n   - Group related policy changes in logical migration files\n   - Include comments explaining the performance optimization rationale\n\n5. Prioritize optimization based on impact:\n   - Focus first on policies applied to tables with the highest query volume\n   - Address policies on tables with the largest row counts\n   - Optimize policies on tables that are frequently joined in complex queries\n\n6. Document performance metrics:\n   - Record baseline query times before optimization\n   - Document the optimization approach for each policy\n   - Create a summary of expected performance improvements",
        "testStrategy": "1. Create a comprehensive test suite that verifies security is maintained:\n   - Develop test cases that verify all access patterns still work correctly\n   - Include negative test cases to ensure unauthorized access is still prevented\n   - Test edge cases like null values, empty results, and boundary conditions\n\n2. Measure and compare performance metrics:\n   - Use EXPLAIN ANALYZE to compare query plans before and after optimization\n   - Benchmark query execution times with realistic data volumes\n   - Test with concurrent users to measure overall system performance improvement\n   - Document performance improvements for each optimized policy\n\n3. Implement automated regression tests:\n   - Create automated tests that verify all security rules are still enforced\n   - Include these tests in the CI/CD pipeline\n   - Ensure tests cover all tables with modified RLS policies\n\n4. Perform load testing:\n   - Simulate high traffic scenarios to verify performance under load\n   - Compare server resource utilization before and after optimization\n   - Verify that database connection pool is not exhausted under load\n\n5. Monitor in staging environment:\n   - Deploy changes to staging environment first\n   - Monitor query performance for at least 24 hours\n   - Check for any unexpected behavior or performance regressions",
        "status": "pending",
        "dependencies": [
          4
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "[Frontend] Crear Página de Solicitud para Abogados (`/abogados/solicitud`)",
        "description": "Diseñar y maquetar la interfaz de usuario para el formulario de solicitud de nuevos abogados en la ruta `/abogados/solicitud`. Debe ser profesional, atractiva y consistente con el diseño general del sitio.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "[Frontend] Implementar Formulario de Solicitud con Validación",
        "description": "Implementar el formulario completo con todos los campos de la tabla `solicitudes_abogado`. Incluir validación de campos en el frontend (ej. con Zod y React Hook Form) y un componente de selección múltiple para las especialidades, cargadas dinámicamente desde la base de datos.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "[Frontend] Implementar Subida Segura de Archivos",
        "description": "Crear un componente de frontend que permita a los usuarios subir de forma segura sus documentos de verificación (DNI, carnet de colegiado, etc.) directamente a un bucket de Supabase Storage. Debe manejar estados de carga, éxito y error.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "[Backend] Crear Edge Function `crear-solicitud-abogado`",
        "description": "Desarrollar una nueva Supabase Edge Function que sirva como endpoint seguro para recibir los datos del formulario de solicitud. Debe estar configurada para aceptar únicamente peticiones POST.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "[Backend] Implementar Lógica de Inserción y Auditoría (RGPD)",
        "description": "Dentro de la Edge Function, añadir la lógica para validar y sanitizar todos los datos recibidos. Luego, insertar la solicitud en la tabla `solicitudes_abogado`. Inmediatamente después, registrar el evento de consentimiento en la tabla `auditoria_seguridad` para cumplir con RGPD.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          4
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "[Integración] Conectar Frontend con Edge Function",
        "description": "Utilizar React Query (useMutation) en el componente del formulario para enviar los datos a la nueva Edge Function `crear-solicitud-abogado`. Gestionar adecuadamente los estados de carga, éxito y error para proporcionar feedback al usuario.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          3,
          5
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 16,
        "title": "[Testing] Realizar Pruebas E2E del Flujo de Solicitud",
        "description": "Realizar pruebas completas del flujo de solicitud. Esto incluye enviar formularios con datos válidos e inválidos, verificar la subida de archivos, y confirmar que los registros se crean correctamente en `solicitudes_abogado` y `auditoria_seguridad` en la base de datos.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          6
        ],
        "priority": "medium",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-18T11:54:54.067Z",
      "updated": "2025-08-18T21:10:41.856Z",
      "description": "Tasks for master context"
    }
  }
}
{
  "master": {
    "tasks": [
      {
        "id": 3,
        "title": "Implement Complete Row Level Security (RLS)",
        "description": "Conduct a comprehensive audit of all database tables and implement strict RLS policies to ensure data access is properly restricted to authorized users only.",
        "details": "1. Create a script to identify all tables in the Supabase database\n2. For each table containing user data or sensitive information:\n   - Review existing RLS policies\n   - Create or update policies for SELECT, INSERT, UPDATE, DELETE operations\n   - Ensure policies follow the principle of least privilege\n3. Implement specific policies based on user roles:\n   - Regular users should only access their own data\n   - Lawyers should only access assigned cases\n   - Admins should have appropriate access controls\n4. Example policy for a user_profiles table:\n```sql\nCREATE POLICY \"Users can view their own profiles\"\nON user_profiles\nFOR SELECT\nUSING (auth.uid() = user_id);\n\nCREATE POLICY \"Users can update their own profiles\"\nON user_profiles\nFOR UPDATE\nUSING (auth.uid() = user_id);\n```\n5. Document all policies in a central security document",
        "testStrategy": "1. Create test cases for each table and policy\n2. Verify access control by attempting unauthorized operations:\n   - Try to access data belonging to other users\n   - Attempt to modify data without proper permissions\n3. Use Supabase's policy simulator to test policies\n4. Create automated tests that verify RLS is working correctly\n5. Document test results and any policy adjustments made",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Fix PostgreSQL Function Vulnerabilities",
        "description": "Address performance issues in Row Level Security (RLS) policies that have been identified as critical after the search_path vulnerabilities were resolved.",
        "status": "pending",
        "dependencies": [],
        "priority": "high",
        "details": "The original search_path vulnerabilities in the 13 PostgreSQL functions have been fixed. Now we need to focus on optimizing RLS policies:\n\n1. Run `supabase db lint` to identify any remaining issues and focus on RLS policy performance warnings\n2. Analyze each RLS policy for performance bottlenecks, particularly:\n   - Policies with complex joins\n   - Policies without proper indexing\n   - Policies with expensive functions\n3. Create a migration SQL file to optimize the identified RLS policies\n4. For each problematic policy, consider:\n   - Adding appropriate indexes\n   - Simplifying policy expressions\n   - Rewriting policies to use more efficient patterns\n5. Example optimization format:\n```sql\n-- Optimize RLS policy for table_name\nDROP POLICY IF EXISTS policy_name ON table_name;\nCREATE POLICY policy_name ON table_name\nFOR operation\nTO role\nUSING (optimized_expression);\n\n-- Add supporting index if needed\nCREATE INDEX IF NOT EXISTS idx_name ON table_name(columns);\n```\n6. Apply the migration to both local and cloud environments\n7. Document all changes made to the policies and their performance impact",
        "testStrategy": "1. Benchmark performance before and after policy changes\n2. Create test cases that specifically target the optimized policies\n3. Use EXPLAIN ANALYZE to verify query plans are using indexes properly\n4. Test with realistic data volumes to ensure optimizations are effective\n5. Monitor query performance in development environment before deploying to production\n6. Document performance improvements with metrics\n7. Include RLS policy performance checks in CI/CD pipeline",
        "subtasks": [
          {
            "id": 1,
            "title": "Document resolution of search_path vulnerabilities",
            "description": "Create documentation noting that the original 13 PostgreSQL functions with mutable search_path issues have been fixed. Include the list of functions that were affected and how they were resolved.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Identify problematic RLS policies",
            "description": "Run performance analysis to identify RLS policies causing performance issues. Create a prioritized list of policies that need optimization.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Create optimization plan for each policy",
            "description": "For each identified problematic policy, document the current implementation, performance issues, and proposed optimization approach.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement RLS policy optimizations",
            "description": "Create migration files with optimized RLS policies and supporting indexes.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Performance testing",
            "description": "Create and run benchmarks to measure performance improvements from the optimized policies.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 5,
        "title": "Implement Rate Limiting",
        "description": "Configure rate limiting on authentication endpoints and other critical API functions to protect against brute force attacks and API abuse.",
        "details": "1. Access Supabase dashboard and navigate to Authentication settings\n2. Configure rate limiting for the following operations:\n   - Login attempts (e.g., 5 attempts per minute)\n   - Password reset requests (e.g., 3 requests per hour)\n   - User registration (e.g., 3 registrations per hour per IP)\n   - API key usage (appropriate limits based on expected usage)\n3. For custom API endpoints, implement rate limiting using middleware:\n```javascript\n// Example using Express Rate Limit middleware\nconst rateLimit = require('express-rate-limit');\n\nconst authLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 5, // 5 requests per windowMs\n  message: 'Too many authentication attempts, please try again later'\n});\n\napp.use('/api/auth/', authLimiter);\n```\n4. Implement appropriate client-side handling of rate limit responses\n5. Add monitoring for rate limit events",
        "testStrategy": "1. Create automated tests that attempt to exceed rate limits\n2. Verify that rate limiting correctly blocks excessive requests\n3. Test client-side handling of rate limit responses\n4. Simulate various attack scenarios to ensure protection\n5. Monitor rate limit events in production to fine-tune limits as needed",
        "priority": "medium",
        "dependencies": [
          3,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Create Audit Trail System",
        "description": "Develop a comprehensive audit logging system to track security events, user actions, and data access for compliance with GDPR and security incident response.",
        "details": "1. Create a new `audit_log` table in Supabase:\n```sql\nCREATE TABLE audit_log (\n  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n  user_id UUID REFERENCES auth.users(id),\n  action TEXT NOT NULL,\n  table_name TEXT,\n  record_id TEXT,\n  old_data JSONB,\n  new_data JSONB,\n  ip_address TEXT,\n  user_agent TEXT,\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n);\n```\n2. Create PostgreSQL triggers for critical tables to automatically log changes:\n```sql\nCREATE OR REPLACE FUNCTION log_audit_event()\nRETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO audit_log (user_id, action, table_name, record_id, old_data, new_data)\n  VALUES (auth.uid(), TG_OP, TG_TABLE_NAME, NEW.id, \n          CASE WHEN TG_OP = 'DELETE' THEN to_jsonb(OLD) ELSE NULL END,\n          CASE WHEN TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN to_jsonb(NEW) ELSE NULL END);\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n```\n3. Apply triggers to relevant tables\n4. Implement frontend logging for authentication events:\n   - Login attempts (successful and failed)\n   - Password changes\n   - Profile updates\n   - Permission changes\n5. Create an admin interface to view and filter audit logs\n6. Implement GDPR-compliant data retention policies for logs",
        "testStrategy": "1. Test automatic logging by performing various database operations\n2. Verify that all required fields are properly captured\n3. Test authentication event logging\n4. Create test cases for each type of auditable action\n5. Verify that sensitive data is properly handled in logs\n6. Test the admin interface for viewing logs\n7. Verify that logs are retained according to policy",
        "priority": "medium",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Configure Leaked Password Protection",
        "description": "Enable Supabase's leaked password protection feature to check user passwords against known compromised password databases like HaveIBeenPwned.",
        "details": "1. Evaluate Supabase pricing plans that include leaked password protection\n2. Once upgraded to an appropriate plan:\n   - Access Supabase dashboard\n   - Navigate to Authentication settings\n   - Enable the 'Leaked Password Protection' feature\n3. Configure the feature to check passwords during:\n   - New user registration\n   - Password changes\n   - Password resets\n4. Implement appropriate error messages in the frontend:\n```javascript\n// Example React component handling leaked password error\nconst handleSignUp = async (email, password) => {\n  try {\n    const { error } = await supabase.auth.signUp({ email, password });\n    if (error) {\n      if (error.message.includes('leaked password')) {\n        setError('This password has been found in a data breach. Please choose a different password.');\n      } else {\n        setError(error.message);\n      }\n    }\n  } catch (error) {\n    setError('An unexpected error occurred');\n  }\n};\n```\n5. Document the feature in user documentation",
        "testStrategy": "1. Test with known compromised passwords to verify detection\n2. Verify that appropriate error messages are displayed\n3. Test password change and reset flows\n4. Ensure the feature doesn't block valid, secure passwords\n5. Monitor user feedback after implementation",
        "priority": "low",
        "dependencies": [
          3,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Plan External Security Audit",
        "description": "Prepare for and coordinate an external security audit (penetration testing) to identify potential vulnerabilities in the application once it reaches a mature state.",
        "details": "1. Research and evaluate security audit providers specializing in web applications and Supabase\n2. Create a comprehensive scope document for the audit, including:\n   - Authentication system\n   - Authorization and access controls\n   - API endpoints\n   - Database security\n   - Frontend security\n   - Infrastructure security\n3. Prepare a budget proposal with cost estimates from 3-5 providers\n4. Create a timeline for the audit process:\n   - Pre-audit preparation\n   - Audit execution (typically 1-2 weeks)\n   - Remediation period\n   - Re-testing\n5. Develop a security documentation package for auditors:\n   - System architecture\n   - Authentication flows\n   - Data models\n   - Security controls already in place\n6. Create a plan for addressing findings post-audit",
        "testStrategy": "1. Conduct an internal pre-audit using tools like OWASP ZAP\n2. Create a checklist of security best practices to verify before the external audit\n3. Develop a process for tracking and prioritizing audit findings\n4. Plan for verification testing after remediation\n5. Create a template for documenting audit results and actions taken",
        "priority": "low",
        "dependencies": [
          3,
          4,
          5,
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Optimize RLS Policies for Performance Improvement",
        "description": "Optimize 50+ Row Level Security (RLS) policies that are causing critical performance issues by refactoring auth function calls and consolidating duplicate policies.",
        "details": "1. Identify all RLS policies that are causing performance issues:\n   - Run `supabase db lint` to identify RLS policies with performance warnings\n   - Use `pg_stat_statements` to identify the slowest queries related to RLS policies\n   - Review all policies that call auth functions directly in the policy definition\n\n2. Refactor RLS policies to optimize auth function calls:\n   - Replace direct auth function calls in row-level evaluations with subqueries\n   - Example transformation:\n     ```sql\n     -- Before (inefficient - evaluates for each row)\n     CREATE POLICY \"Users can view their own data\" ON \"public\".\"profiles\"\n       USING (auth.uid() = user_id);\n       \n     -- After (optimized - evaluates once per query)\n     CREATE POLICY \"Users can view their own data\" ON \"public\".\"profiles\"\n       USING ((SELECT auth.uid()) = user_id);\n     ```\n\n3. Consolidate duplicate or overlapping policies:\n   - Identify tables with multiple similar policies that can be combined\n   - Create a spreadsheet to track all policies, their purpose, and consolidation opportunities\n   - Develop a migration plan that ensures no security gaps during transition\n\n4. Create database migration files:\n   - For each table with policies to optimize, create DROP and CREATE statements\n   - Group related policy changes in logical migration files\n   - Include comments explaining the performance optimization rationale\n\n5. Prioritize optimization based on impact:\n   - Focus first on policies applied to tables with the highest query volume\n   - Address policies on tables with the largest row counts\n   - Optimize policies on tables that are frequently joined in complex queries\n\n6. Document performance metrics:\n   - Record baseline query times before optimization\n   - Document the optimization approach for each policy\n   - Create a summary of expected performance improvements",
        "testStrategy": "1. Create a comprehensive test suite that verifies security is maintained:\n   - Develop test cases that verify all access patterns still work correctly\n   - Include negative test cases to ensure unauthorized access is still prevented\n   - Test edge cases like null values, empty results, and boundary conditions\n\n2. Measure and compare performance metrics:\n   - Use EXPLAIN ANALYZE to compare query plans before and after optimization\n   - Benchmark query execution times with realistic data volumes\n   - Test with concurrent users to measure overall system performance improvement\n   - Document performance improvements for each optimized policy\n\n3. Implement automated regression tests:\n   - Create automated tests that verify all security rules are still enforced\n   - Include these tests in the CI/CD pipeline\n   - Ensure tests cover all tables with modified RLS policies\n\n4. Perform load testing:\n   - Simulate high traffic scenarios to verify performance under load\n   - Compare server resource utilization before and after optimization\n   - Verify that database connection pool is not exhausted under load\n\n5. Monitor in staging environment:\n   - Deploy changes to staging environment first\n   - Monitor query performance for at least 24 hours\n   - Check for any unexpected behavior or performance regressions",
        "status": "pending",
        "dependencies": [
          4
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "[Frontend] Crear Página de Solicitud para Abogados (`/abogados/solicitud`)",
        "description": "Diseñar y maquetar la interfaz de usuario para el formulario de solicitud de nuevos abogados en la ruta `/abogados/solicitud`. Debe ser profesional, atractiva y consistente con el diseño general del sitio.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "[Frontend] Implementar Formulario de Solicitud con Validación",
        "description": "Implementar el formulario completo con todos los campos de la tabla `solicitudes_abogado`. Incluir validación de campos en el frontend (ej. con Zod y React Hook Form) y un componente de selección múltiple para las especialidades, cargadas dinámicamente desde la base de datos.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "[Frontend] Implementar Subida Segura de Archivos",
        "description": "Crear un componente de frontend que permita a los usuarios subir de forma segura sus documentos de verificación (DNI, carnet de colegiado, etc.) directamente a un bucket de Supabase Storage. Debe manejar estados de carga, éxito y error.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "[Backend] Crear Edge Function `crear-solicitud-abogado`",
        "description": "Desarrollar una nueva Supabase Edge Function que sirva como endpoint seguro para recibir los datos del formulario de solicitud. Debe estar configurada para aceptar únicamente peticiones POST.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "[Backend] Implementar Lógica de Inserción y Auditoría (RGPD)",
        "description": "Dentro de la Edge Function, añadir la lógica para validar y sanitizar todos los datos recibidos. Luego, insertar la solicitud en la tabla `solicitudes_abogado`. Inmediatamente después, registrar el evento de consentimiento en la tabla `auditoria_seguridad` para cumplir con RGPD.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          4
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "[Integración] Conectar Frontend con Edge Function",
        "description": "Utilizar React Query (useMutation) en el componente del formulario para enviar los datos a la nueva Edge Function `crear-solicitud-abogado`. Gestionar adecuadamente los estados de carga, éxito y error para proporcionar feedback al usuario.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          3,
          5
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 16,
        "title": "[Testing] Realizar Pruebas E2E del Flujo de Solicitud",
        "description": "Realizar pruebas completas del flujo de solicitud. Esto incluye enviar formularios con datos válidos e inválidos, verificar la subida de archivos, y confirmar que los registros se crean correctamente en `solicitudes_abogado` y `auditoria_seguridad` en la base de datos.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          6
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 17,
        "title": "Fase 1: Implementar Migración de BD para Kanban",
        "description": "Crear un nuevo tipo ENUM en la base de datos llamado etapa_kanban_enum y añadir una nueva columna llamada `etapa` a la tabla `casos`. Esta columna utilizará el nuevo ENUM y tendrá un valor por defecto. Todo esto se gestionará a través de un nuevo archivo de migración de Supabase.",
        "details": "",
        "testStrategy": "Verificar que la migración se aplica correctamente en el entorno local de Supabase y que la nueva columna `etapa` existe en la tabla `casos` con el tipo y valor por defecto correctos.",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 18,
        "title": "Fase 2: Instalar Librería y Crear Componente Kanban",
        "description": "Instalar la librería `shadcn-kanban-board` usando el comando `npx shadcn@latest add ...` y crear el archivo para el nuevo componente `KanbanBoard.tsx` en la estructura de componentes del frontend. El componente debe renderizar una estructura básica con columnas fijas que representen las etapas del Kanban.",
        "details": "",
        "testStrategy": "Verificar que la librería se instala correctamente y que el nuevo componente `KanbanBoard.tsx` se renderiza sin errores en la aplicación, mostrando las columnas vacías.",
        "status": "done",
        "dependencies": [
          17
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 19,
        "title": "Fase 2: Conectar Kanban con Datos de Supabase",
        "description": "En el componente `KanbanBoard.tsx`, implementar una función para llamar a Supabase y obtener todos los casos asignados al abogado actual. Los datos recuperados se deben procesar y utilizar para renderizar los componentes `CaseCard` dentro de las columnas correspondientes del tablero Kanban, según su valor en el nuevo campo `etapa`.",
        "details": "",
        "testStrategy": "Verificar que el tablero Kanban muestra correctamente los `CaseCard` en sus columnas respectivas. Probar con casos en diferentes `etapas` para asegurar que la distribución es correcta.",
        "status": "done",
        "dependencies": [
          18
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 20,
        "title": "Fase 3: Crear RPC para Actualizar Etapa del Caso",
        "description": "Crear una nueva función de base de datos (RPC) en Supabase llamada `actualizar_etapa_caso`. Esta función recibirá un `caso_id` y una `nueva_etapa` como parámetros. Implementará la lógica para verificar los permisos del usuario (debe ser el abogado asignado o un admin) antes de actualizar la columna `etapa` del caso correspondiente en la base de datos.",
        "details": "",
        "testStrategy": "Probar la función RPC directamente desde el editor SQL de Supabase para asegurar que actualiza la etapa correctamente cuando los permisos son válidos y devuelve un error cuando no lo son.",
        "status": "done",
        "dependencies": [
          17
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 21,
        "title": "Fase 3: Implementar Lógica Drag and Drop en Frontend",
        "description": "En `KanbanBoard.tsx`, configurar la lógica de `dnd-kit`. Al detectar el evento `onDragEnd`, se debe obtener el `caso_id` y la `nueva_etapa` (la columna de destino). Luego, invocar la función RPC `actualizar_etapa_caso` de Supabase. Implementar una actualización optimista de la UI para una experiencia fluida.",
        "details": "",
        "testStrategy": "Arrastrar un `CaseCard` a una nueva columna y verificar en la base de datos que el campo `etapa` se ha actualizado correctamente. Asegurarse de que la UI refleja el cambio de forma inmediata y persistente.",
        "status": "done",
        "dependencies": [
          19,
          20
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 22,
        "title": "Fase 4: Mejoras de UI/UX para Kanban (Post-MVP)",
        "description": "Una vez que el tablero Kanban sea completamente funcional, añadir funcionalidades adicionales para mejorar la experiencia del usuario. Esto incluye: 1. Controles de filtro en la UI para buscar casos por cliente o prioridad. 2. Indicadores visuales en las `CaseCard` (ej. para urgencia o notificaciones). 3. Una nueva vista o página para consultar los casos archivados (aquellos en etapa `finalizado`).",
        "details": "",
        "testStrategy": "Verificar que los filtros funcionan correctamente y que los nuevos indicadores visuales se muestran según la lógica definida. Comprobar que la vista de archivo solo muestra los casos finalizados.",
        "status": "pending",
        "dependencies": [
          21
        ],
        "priority": "low",
        "subtasks": []
      },
      {
        "id": 23,
        "title": "[Pago Anónimo] Modificar Base de Datos",
        "description": "Crear una migración de Supabase para añadir la columna 'token_reclamacion_pago' a la tabla 'casos' y el estado 'pago_realizado_pendiente_registro' al ENUM 'caso_estado_enum'.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 24,
        "title": "[Pago Anónimo] Crear Edge Function de Checkout",
        "description": "Crear una nueva Supabase Edge Function llamada 'crear-sesion-checkout-anonima' que reciba un 'caso_id', cree una sesión de Stripe con el 'caso_id' en los metadatos y devuelva la URL de pago.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          23
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 25,
        "title": "[Pago Anónimo] Refactorizar Webhook de Stripe",
        "description": "Refactorizar la función 'stripe-webhook' para manejar el evento 'checkout.session.completed' de pagos anónimos. Debe crear un usuario si no existe (o vincularlo si ya existe) y enviar un email con un enlace para establecer la contraseña.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          23
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 26,
        "title": "[Pago Anónimo] Implementar Flujo en Frontend",
        "description": "Modificar Chat.tsx para que al hacer clic en 'Pagar Consulta' se llame a la nueva función 'crear-sesion-checkout-anonima' y se redirija al usuario a Stripe. Crear una nueva página '/pago-exitoso' para mostrar un mensaje de confirmación post-pago.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          24
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 27,
        "title": "[Pago Anónimo] Pruebas Integrales del Nuevo Flujo",
        "description": "Realizar pruebas de extremo a extremo del nuevo flujo. Verificar el pago anónimo, la creación automática de la cuenta, la recepción del email para establecer contraseña y la correcta vinculación del caso a la nueva cuenta. Probar también el caso de un usuario ya existente.",
        "details": "",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [
          25,
          26
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 28,
        "title": "[Propuesta Pública] Crear Edge Function 'crear-sesion-checkout-propuesta-publica'",
        "description": "Desarrollar una nueva Supabase Edge Function que cree sesiones de checkout en Stripe para usuarios que desean pagar por una consulta después de ver una propuesta pública, incluyendo el origen 'propuesta_publica' en los metadatos.",
        "details": "Esta función debe seguir un patrón similar a la función 'crear-sesion-checkout-anonima' pero adaptada al flujo específico de propuestas públicas:\n\n1. Crear un nuevo archivo en `/supabase/functions/crear-sesion-checkout-propuesta-publica/index.ts`\n2. Configurar CORS y validación de solicitudes POST\n3. Implementar la lógica para:\n   - Recibir el ID de la propuesta pública como parámetro\n   - Validar que la propuesta existe y está disponible para pago\n   - Obtener los detalles necesarios de la propuesta (precio, título, etc.)\n   - Crear una sesión de checkout en Stripe con:\n     - El precio correspondiente a una consulta\n     - Metadatos que incluyan `propuesta_id`, `flujo_origen: 'propuesta_publica'` y cualquier otro dato relevante\n   - Configurar URLs de éxito y cancelación apropiadas\n4. Devolver la URL de la sesión de checkout para redireccionar al usuario\n5. Implementar manejo de errores adecuado con mensajes claros\n6. Documentar la función con comentarios explicativos\n7. Asegurar que la función esté protegida con las políticas de seguridad adecuadas\n\nLa función debe integrarse con el sistema existente de pagos y seguir las mismas prácticas de seguridad y auditoría.",
        "testStrategy": "1. Pruebas unitarias:\n   - Verificar que la función rechaza métodos que no sean POST\n   - Comprobar que valida correctamente los parámetros de entrada\n   - Verificar el manejo de errores cuando la propuesta no existe\n\n2. Pruebas de integración:\n   - Crear una propuesta pública de prueba\n   - Invocar la función con el ID de la propuesta\n   - Verificar que devuelve una URL de Stripe válida\n   - Comprobar que los metadatos incluyen `flujo_origen: 'propuesta_publica'`\n   - Verificar que la sesión de Stripe se crea con el precio correcto\n\n3. Pruebas de extremo a extremo:\n   - Completar un flujo de pago real usando la URL generada\n   - Verificar que el webhook de Stripe procesa correctamente el pago\n   - Comprobar que el sistema actualiza el estado de la propuesta/consulta adecuadamente\n\n4. Pruebas de seguridad:\n   - Intentar acceder a la función sin autenticación adecuada\n   - Verificar que no se pueden manipular los precios o metadatos",
        "status": "pending",
        "dependencies": [
          24,
          25
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 29,
        "title": "[Frontend] Modificar Componente de Propuestas Públicas para Implementar Pago Directo",
        "description": "Identificar y modificar el componente frontend que muestra las propuestas públicas para implementar el flujo de pago directo, cambiando el botón \"Pagar Consulta\" para usar la nueva función Edge.",
        "details": "Esta tarea implica modificar el componente de propuestas públicas para implementar un flujo de pago directo:\n\n1. Identificar el componente o componentes que muestran las propuestas públicas (probablemente en la carpeta `/components/propuestas/` o similar).\n\n2. Localizar el botón \"Pagar Consulta\" actual que abre el modal de registro.\n\n3. Modificar la funcionalidad del botón para:\n   - Eliminar la apertura del modal de registro\n   - Implementar una llamada a la nueva función Edge 'crear-sesion-checkout-propuesta-publica'\n   - Pasar el ID de la propuesta pública como parámetro a la función\n   - Capturar la respuesta que contiene la URL de la sesión de checkout de Stripe\n   - Redirigir al usuario directamente a la URL de Stripe\n\n4. Código de ejemplo para la implementación:\n```tsx\n// Antes\nconst handlePaymentClick = () => {\n  setShowRegistrationModal(true);\n};\n\n// Después\nconst handlePaymentClick = async (propuestaId: string) => {\n  try {\n    setIsLoading(true);\n    const response = await fetch(\n      `${process.env.NEXT_PUBLIC_SUPABASE_URL}/functions/v1/crear-sesion-checkout-propuesta-publica`,\n      {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY}`\n        },\n        body: JSON.stringify({ propuesta_id: propuestaId })\n      }\n    );\n    \n    if (!response.ok) {\n      throw new Error('Error al crear la sesión de checkout');\n    }\n    \n    const { url } = await response.json();\n    window.location.href = url;\n  } catch (error) {\n    console.error('Error:', error);\n    toast.error('Ocurrió un error al procesar el pago. Por favor, inténtalo de nuevo.');\n  } finally {\n    setIsLoading(false);\n  }\n};\n```\n\n5. Añadir un estado de carga para mejorar la experiencia de usuario:\n```tsx\nconst [isLoading, setIsLoading] = useState(false);\n\n// En el botón\n<Button \n  onClick={() => handlePaymentClick(propuesta.id)} \n  disabled={isLoading}\n>\n  {isLoading ? 'Procesando...' : 'Pagar Consulta'}\n</Button>\n```\n\n6. Asegurarse de que la redirección a la página de éxito después del pago funcione correctamente con el nuevo flujo.",
        "testStrategy": "1. Pruebas de componente:\n   - Verificar que el botón \"Pagar Consulta\" ya no abre el modal de registro\n   - Comprobar que al hacer clic en el botón se realiza la llamada a la función Edge con los parámetros correctos\n   - Verificar que se muestra un estado de carga mientras se procesa la solicitud\n\n2. Pruebas de integración:\n   - Crear una propuesta pública de prueba\n   - Hacer clic en \"Pagar Consulta\" y verificar que se redirige correctamente a la página de checkout de Stripe\n   - Completar un pago de prueba en el entorno de desarrollo de Stripe\n   - Verificar que después del pago se redirige a la página de éxito\n\n3. Pruebas de manejo de errores:\n   - Simular un error en la llamada a la función Edge y verificar que se muestra un mensaje de error apropiado\n   - Comprobar que el botón se habilita nuevamente después de un error\n\n4. Pruebas de experiencia de usuario:\n   - Verificar que la transición entre la aplicación y Stripe es fluida\n   - Comprobar que los mensajes de carga y error son claros y útiles",
        "status": "pending",
        "dependencies": [
          28,
          26
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 30,
        "title": "[Webhook Stripe] Corregir Flujo de Creación de Cuenta para Usuarios Anónimos",
        "description": "Verificar y corregir el flujo de creación de cuenta en el webhook de Stripe para usuarios anónimos, asegurando que se envíe un único email de activación con enlace funcional y que el usuario quede marcado como no confirmado hasta completar el proceso.",
        "details": "Esta tarea implica revisar y corregir el proceso de creación de cuentas en el webhook de Stripe para garantizar un flujo correcto tanto para chat como para propuestas públicas:\n\n1. Revisar el código actual en la función stripe-webhook, específicamente el manejo del evento 'checkout.session.completed' para pagos anónimos.\n\n2. Modificar la lógica de creación de usuarios para:\n   - Establecer explícitamente `email_confirm: false` al crear nuevos usuarios\n   - Generar un enlace de activación personalizado en lugar de usar el flujo estándar de Supabase\n   - Asegurar que el usuario quede marcado como no confirmado hasta que complete el proceso de activación\n\n3. Implementar mecanismos para prevenir la duplicación de emails:\n   - Verificar si ya se ha enviado un email de activación antes de enviar uno nuevo\n   - Implementar un sistema de bloqueo (lock) o verificación de estado para evitar condiciones de carrera\n\n4. Actualizar la plantilla de email para incluir el enlace de activación personalizado:\n   - El enlace debe dirigir a una página específica para completar el registro\n   - Incluir parámetros de seguridad como token de un solo uso y timestamp\n\n5. Revisar y corregir la lógica de vinculación de casos/propuestas al usuario:\n   - Asegurar que los casos se vinculen correctamente al usuario recién creado\n   - Verificar que la información de pago se asocie adecuadamente\n\n6. Implementar logging detallado para facilitar la depuración:\n   - Registrar cada paso del proceso\n   - Capturar errores específicos relacionados con la creación de usuarios y envío de emails",
        "testStrategy": "1. Pruebas unitarias:\n   - Verificar que la función establece correctamente `email_confirm: false` al crear usuarios\n   - Comprobar que el enlace de activación se genera correctamente\n   - Validar que el sistema detecta y previene emails duplicados\n\n2. Pruebas de integración:\n   - Realizar un pago anónimo completo a través del chat y verificar:\n     * Que se crea el usuario correctamente en estado no confirmado\n     * Que se envía un único email con el enlace de activación\n     * Que al usar el enlace, la cuenta se activa correctamente\n   - Realizar un pago anónimo a través de una propuesta pública y verificar el mismo flujo\n   - Probar el escenario donde un usuario intenta pagar dos veces (verificar que no se envían emails duplicados)\n\n3. Pruebas de borde:\n   - Verificar el comportamiento cuando hay errores de red durante el envío del email\n   - Probar con direcciones de email inválidas o con formatos especiales\n   - Comprobar el comportamiento cuando Stripe envía el mismo evento múltiples veces\n\n4. Verificación manual:\n   - Recibir y verificar el email de activación en diferentes clientes de correo\n   - Comprobar que el enlace funciona correctamente en diferentes navegadores\n   - Verificar que la experiencia de usuario es clara y sin errores",
        "status": "in-progress",
        "dependencies": [
          25,
          27,
          28
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 31,
        "title": "[Testing] Implementar Pruebas de Integración para Flujo de Pago Anónimo",
        "description": "Desarrollar y ejecutar pruebas de integración completas para validar el flujo de pago anónimo en ambos escenarios (chat y propuesta pública), verificando el procesamiento correcto del webhook, la creación de cuentas y el envío de emails.",
        "details": "Esta tarea implica crear un conjunto completo de pruebas para validar el flujo de pago anónimo en ambos escenarios:\n\n1. Preparar el entorno de pruebas:\n   - Configurar un entorno de prueba aislado con Stripe en modo de prueba\n   - Crear datos de prueba para ambos escenarios (chat y propuesta pública)\n   - Configurar interceptores para capturar y verificar emails enviados\n\n2. Pruebas para el escenario de chat:\n   - Simular un pago anónimo a través del flujo de chat\n   - Verificar que el webhook procese correctamente el evento con `flujo_origen: 'chat'`\n   - Comprobar la creación correcta de la cuenta de usuario con `email_confirm: false`\n   - Validar que se envía el email de activación con el enlace correcto\n   - Verificar que el caso se vincula correctamente a la nueva cuenta\n\n3. Pruebas para el escenario de propuesta pública:\n   - Simular un pago anónimo a través del flujo de propuesta pública\n   - Verificar que el webhook procese correctamente el evento con `flujo_origen: 'propuesta_publica'`\n   - Comprobar la creación correcta de la cuenta de usuario\n   - Validar que se envía el email de activación\n   - Verificar que la propuesta se vincula correctamente a la nueva cuenta\n\n4. Pruebas para usuarios existentes:\n   - Simular pagos anónimos utilizando emails de usuarios ya existentes\n   - Verificar que no se crean cuentas duplicadas\n   - Comprobar que los casos/propuestas se vinculan a la cuenta existente\n   - Validar que no se envían emails de activación innecesarios\n\n5. Pruebas de escenarios de error:\n   - Simular fallos en la creación de cuentas\n   - Probar interrupciones en el proceso de pago\n   - Verificar el manejo de errores en el webhook\n\n6. Verificar que los flujos existentes de cobro del abogado no se ven afectados:\n   - Ejecutar pruebas de regresión en los flujos de cobro existentes\n   - Comprobar que no hay interferencias entre los diferentes flujos",
        "testStrategy": "1. Pruebas automatizadas:\n   - Desarrollar scripts de prueba que simulen pagos completos en Stripe (modo de prueba)\n   - Utilizar herramientas como Jest o Cypress para automatizar las pruebas de integración\n   - Implementar mocks para servicios externos cuando sea necesario\n\n2. Verificación del webhook:\n   - Utilizar Stripe CLI para simular eventos de webhook localmente\n   - Verificar en la base de datos que los eventos se procesan correctamente\n   - Comprobar los logs para confirmar el procesamiento adecuado según el `flujo_origen`\n\n3. Validación de creación de cuentas:\n   - Consultar la base de datos para verificar que las cuentas se crean con los atributos correctos\n   - Comprobar que no se crean cuentas duplicadas para emails existentes\n   - Verificar que el campo `email_confirm` se establece correctamente\n\n4. Verificación de emails:\n   - Configurar un servicio de captura de emails (como Mailhog o similar)\n   - Verificar que se envían los emails correctos con los enlaces de activación\n   - Comprobar el contenido y formato de los emails\n\n5. Pruebas de flujo completo:\n   - Seguir el proceso completo desde el pago hasta la activación de la cuenta\n   - Verificar que el usuario puede establecer su contraseña y acceder a su cuenta\n   - Comprobar que puede ver el caso o propuesta vinculada\n\n6. Pruebas de regresión:\n   - Ejecutar pruebas en los flujos de cobro existentes para abogados\n   - Verificar que no hay efectos secundarios en otras funcionalidades\n\n7. Documentación:\n   - Documentar todos los casos de prueba ejecutados\n   - Registrar los resultados y cualquier problema encontrado\n   - Crear un informe final de pruebas",
        "status": "pending",
        "dependencies": [
          27,
          28,
          30
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 32,
        "title": "Documentar Avances del Flujo de Pago Anónimo en SEPARACION_DASHBOARDS.md",
        "description": "Actualizar la documentación técnica en el archivo SEPARACION_DASHBOARDS.md para reflejar los avances implementados en el flujo de pago anónimo, incluyendo la nueva funcionalidad para propuestas públicas, modificaciones al webhook y mejoras en la creación de cuentas.",
        "details": "Esta tarea implica documentar de manera clara y detallada todos los cambios realizados en el flujo de pago anónimo:\n\n1. Revisar los cambios implementados en:\n   - La nueva función Edge para propuestas públicas (crear-sesion-checkout-propuesta-publica)\n   - Las modificaciones al webhook de Stripe para la creación de cuentas de usuarios anónimos\n   - El flujo completo de pago anónimo tanto para chat como para propuestas públicas\n\n2. Actualizar el archivo SEPARACION_DASHBOARDS.md con:\n   - Diagrama de flujo actualizado que muestre el proceso completo de pago anónimo en ambos escenarios\n   - Descripción detallada de cada componente del flujo y su interacción con otros sistemas\n   - Explicación de los cambios realizados en el webhook para garantizar la correcta creación de cuentas\n   - Documentación de la nueva función Edge para propuestas públicas\n   - Detalles sobre el manejo de emails de activación y el proceso de confirmación de cuenta\n\n3. Incluir información técnica relevante:\n   - Estructura de los metadatos utilizados en las sesiones de Stripe\n   - Campos importantes en la base de datos que se modifican durante el proceso\n   - Consideraciones de seguridad implementadas\n   - Posibles escenarios de error y cómo se manejan\n\n4. Mantener la consistencia con la documentación existente:\n   - Seguir el mismo formato y estilo del documento actual\n   - Asegurar que la nueva documentación se integre correctamente con las secciones existentes\n   - Actualizar cualquier referencia cruzada a otras partes de la documentación",
        "testStrategy": "1. Revisión de precisión técnica:\n   - Verificar que todos los flujos documentados corresponden exactamente a la implementación actual\n   - Confirmar que los diagramas representan con precisión el flujo de datos y las interacciones entre componentes\n   - Validar que todas las referencias a endpoints, funciones y tablas de la base de datos son correctas\n\n2. Revisión de completitud:\n   - Comprobar que se han documentado todos los aspectos del flujo de pago anónimo\n   - Verificar que se incluyen tanto el escenario de chat como el de propuestas públicas\n   - Confirmar que se documentan todos los posibles caminos de ejecución (casos de éxito y manejo de errores)\n\n3. Revisión por pares:\n   - Solicitar a otro desarrollador del equipo que revise la documentación\n   - Verificar que la documentación es comprensible para alguien que no ha trabajado directamente en la implementación\n   - Incorporar feedback y realizar ajustes necesarios\n\n4. Prueba de seguimiento de procesos:\n   - Utilizar la documentación para seguir manualmente el flujo completo y verificar que no hay pasos faltantes\n   - Intentar reproducir un escenario de pago anónimo siguiendo únicamente las instrucciones de la documentación",
        "status": "pending",
        "dependencies": [
          30,
          28,
          31,
          27
        ],
        "priority": "low",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-18T11:54:54.067Z",
      "updated": "2025-08-26T09:30:16.846Z",
      "description": "Tasks for master context"
    }
  },
  "feature-seo-mvp": {
    "tasks": [
      {
        "id": 1,
        "title": "Instalar y configurar dependencias SEO",
        "description": "Instalar las librerías necesarias (@dr.pogodin/react-helmet, react-router-dom) y configurar el HelmetProvider en el punto de entrada de la aplicación.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Crear fuente de datos MVP",
        "description": "Crear un archivo JSON estático (mercantil-landings.json) que contenga los datos estructurados para cada landing page de ciudad (título, descripción, contenido, FAQs, etc.).",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Implementar rutas dinámicas",
        "description": "Configurar React Router para manejar las nuevas rutas dinámicas, como '/derecho-mercantil/:ciudad', y las rutas estáticas para las páginas hub.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Construir componente dinámico LandingMercantilPage.jsx",
        "description": "Crear el componente principal que leerá los datos del JSON según el parámetro de la URL y renderizará el contenido, los meta tags con Helmet y el JSON-LD.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Construir las páginas Hub",
        "description": "Desarrollar las páginas de categoría, como '/derecho-mercantil', que servirán como índice y enlazarán a las landings de ciudad específicas.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Integrar componentes compartidos (Footer, Consentimiento)",
        "description": "Asegurarse de que los componentes existentes, como el Footer y el banner de consentimiento de cookies, se incluyan en las nuevas plantillas de página.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-09-02T13:50:40.037Z",
      "updated": "2025-09-02T14:06:30.042Z",
      "description": "Tag created on 2/9/2025"
    }
  },
  "feature-chat-dashboard": {
    "tasks": [
      {
        "id": 1,
        "title": "Initialize Project and Integrate Vercel AI SDK Elements",
        "description": "Set up the project environment and install @ai-sdk/react to enable use of PromptInput and PromptInputActionAddAttachments components.",
        "details": "Install all required dependencies, especially @ai-sdk/react. Ensure the project is configured to use shadcn/ui for design consistency. Scaffold the folder structure for components, hooks, and services as per the PRD.",
        "testStrategy": "Verify that the project builds successfully and that the imported components render without errors in a test page.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize Project Environment",
            "description": "Create a new Next.js project with TypeScript, ESLint, and configure the src/ directory structure. Set up initial version control and ensure the project is ready for dependency installation.",
            "dependencies": [],
            "details": "Use `npx create-next-app@latest` to scaffold the project. Select TypeScript, ESLint, Tailwind CSS (if needed for shadcn/ui compatibility), and src/ directory options. Initialize a Git repository and make the first commit with the base project files.",
            "status": "done",
            "testStrategy": "Verify that the project builds and runs locally with `npm run dev`. Confirm that the initial folder structure matches PRD requirements."
          },
          {
            "id": 2,
            "title": "Install and Configure Core Dependencies",
            "description": "Install @ai-sdk/react, ai, and any other required packages (e.g., shadcn/ui, zod). Ensure all dependencies are correctly added and available for import.",
            "dependencies": [],
            "details": "Run `npm install ai @ai-sdk/react zod` and follow shadcn/ui installation instructions. Update package.json and ensure peer dependencies are resolved. Add shadcn/ui setup scripts if required.",
            "status": "done",
            "testStrategy": "Check that all dependencies are listed in package.json and can be imported in a test file without errors."
          },
          {
            "id": 3,
            "title": "Scaffold Project Folder Structure",
            "description": "Create folders for components, hooks, and services as specified in the PRD. Add placeholder files for key modules to establish the architecture.",
            "dependencies": [],
            "details": "Create directories such as `src/components`, `src/hooks`, and `src/services`. Add README.md or index.ts files to each folder. Create placeholder files for PromptInput and PromptInputActionAddAttachments components.",
            "status": "done",
            "testStrategy": "Verify that the folder structure matches the PRD and that all placeholder files exist and are accessible."
          },
          {
            "id": 4,
            "title": "Integrate Vercel AI SDK Components",
            "description": "Import and set up PromptInput and PromptInputActionAddAttachments components from @ai-sdk/react in a test page. Ensure they render and function minimally.",
            "dependencies": [],
            "details": "Create a test page (e.g., `src/pages/test-ai.tsx`) and import the SDK components. Render them with basic props and handlers. Confirm that the components mount and display in the browser.",
            "status": "done",
            "testStrategy": "Open the test page in the browser and verify that both components render without errors. Check console for warnings or issues."
          },
          {
            "id": 5,
            "title": "Configure shadcn/ui for Design Consistency",
            "description": "Set up shadcn/ui and apply its design system to the test page and SDK components. Ensure consistent styling and theme integration.",
            "dependencies": [],
            "details": "Follow shadcn/ui setup instructions to configure theme and global styles. Wrap SDK components in shadcn/ui layout containers and apply sample styles. Adjust Tailwind or CSS config as needed for compatibility.",
            "status": "done",
            "testStrategy": "Visually inspect the test page to confirm that all components use shadcn/ui styles and match the intended design system."
          }
        ]
      },
      {
        "id": 2,
        "title": "Implement NuevaConsultaSection Orchestrator Component",
        "description": "Create NuevaConsultaSection.tsx to manage the two-step flow: initial form and chat interface.",
        "details": "Develop logic to render a text input form for the initial query. On submit, trigger case creation and transition to the chat interface. Use state to manage step transitions.",
        "testStrategy": "Test that the two-step flow works: after submitting the initial query, the chat interface appears. Validate state transitions and correct rendering.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Set Up Component Structure and State Management",
            "description": "Create the NuevaConsultaSection.tsx file and define the component structure, including state to manage the current step (initial form vs. chat interface).",
            "dependencies": [],
            "details": "Initialize a functional React component. Use useState to track which step is active (e.g., 'form' or 'chat'). Prepare the component to conditionally render either the initial form or the chat interface based on this state.",
            "status": "done",
            "testStrategy": "Render the component and verify that the correct UI is shown for the default step."
          },
          {
            "id": 2,
            "title": "Implement Initial Query Input Form",
            "description": "Develop the UI and logic for the initial text input form where users enter their query.",
            "dependencies": [
              "2.1"
            ],
            "details": "Create a controlled input field and a submit button. Manage input value with useState. Add basic validation (e.g., non-empty input). On submit, prevent default form behavior and call a handler to process the input.",
            "status": "done",
            "testStrategy": "Test that the form renders, accepts input, validates, and calls the submit handler with the correct value."
          },
          {
            "id": 3,
            "title": "Integrate Case Creation Logic",
            "description": "Implement the logic to trigger case creation when the initial query is submitted.",
            "dependencies": [
              "2.2"
            ],
            "details": "In the form submit handler, call the API or function responsible for creating a new case using the input value. Handle loading and error states. Store the resulting case ID in component state for use in the chat interface.",
            "status": "done",
            "testStrategy": "Mock the case creation API and verify that it is called with the correct data. Check that the case ID is stored and errors are handled."
          },
          {
            "id": 4,
            "title": "Transition to and Render Chat Interface",
            "description": "Switch the component state to display the chat interface after successful case creation, passing necessary props such as the case ID.",
            "dependencies": [
              "2.3"
            ],
            "details": "Upon successful case creation, update the step state to 'chat'. Render the chat interface component, ensuring it receives the case ID and any other required props. Hide or disable the initial form.",
            "status": "done",
            "testStrategy": "Test that submitting the form transitions the UI to the chat interface and that the chat receives the correct case ID."
          },
          {
            "id": 5,
            "title": "Implement State Reset and Step Navigation Logic",
            "description": "Add logic to allow resetting the flow or navigating back to the initial form if needed (e.g., for error recovery or new queries).",
            "dependencies": [
              "2.4"
            ],
            "details": "Provide a mechanism (such as a button or callback) to reset the component state to the initial step. Ensure all relevant state (input, case ID, errors) is cleared when resetting.",
            "status": "done",
            "testStrategy": "Test that the reset/navigation works as intended, returning the user to the initial form and clearing previous state."
          }
        ]
      },
      {
        "id": 3,
        "title": "Develop CustomChat UI Component",
        "description": "Build CustomChat.tsx to display the chat interface, including message rendering, file attachment UI, and typing indicators.",
        "details": "Use PromptInput and PromptInputActionAddAttachments for input and file selection. Render chat messages, show a typing indicator, and ensure the UI matches shadcn/ui design guidelines.",
        "testStrategy": "Check that messages are displayed, files can be selected, and the typing indicator appears when expected. Validate UI against design requirements.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Set Up CustomChat Component Structure and State",
            "description": "Create the CustomChat.tsx file, import required dependencies, and establish the component's state for messages, input, attachments, and typing status.",
            "dependencies": [],
            "details": "Start by creating CustomChat.tsx in the appropriate components directory. Import React, useState, useEffect, and any required hooks from the Vercel AI SDK (such as useChat). Define state variables for chat messages, input value, attached files, and a boolean for typing indicator. Ensure the component is structured to allow for future expansion and matches shadcn/ui conventions.",
            "status": "done",
            "testStrategy": "Render the component in isolation and verify that state variables initialize correctly and the component mounts without errors."
          },
          {
            "id": 2,
            "title": "Integrate PromptInput and File Attachment UI",
            "description": "Implement the chat input area using PromptInput and PromptInputActionAddAttachments, enabling users to type messages and select files for attachment.",
            "dependencies": [
              "3.1"
            ],
            "details": "Import PromptInput and PromptInputActionAddAttachments from @ai-sdk/react. Place them in the chat input area at the bottom of the UI. Wire up handlers to update the input state and manage file selection, ensuring that selected files are previewed and can be removed before sending. Style the input area to match shadcn/ui design guidelines.",
            "status": "done",
            "testStrategy": "Test that users can type messages, select files, see file previews, and remove files before sending."
          },
          {
            "id": 3,
            "title": "Implement Message Rendering and Auto-Scroll",
            "description": "Render the list of chat messages, including support for text and file attachments, and implement auto-scroll to the latest message.",
            "dependencies": [
              "3.1"
            ],
            "details": "Map over the messages state to render each message using shadcn/ui or custom message components. Display text, markdown, and file attachments as appropriate. Implement auto-scroll behavior so the chat view scrolls to the newest message when messages update. Ensure accessibility and responsive design.",
            "status": "done",
            "testStrategy": "Send and receive messages, including those with attachments, and verify that all messages render correctly and the chat view auto-scrolls to the latest message."
          },
          {
            "id": 4,
            "title": "Add Typing Indicator Logic and UI",
            "description": "Show a typing indicator when the AI or another user is composing a message, updating the UI in real time.",
            "dependencies": [
              "3.1",
              "3.3"
            ],
            "details": "Add a typing indicator component below the message list. Update the typing state based on incoming events or status from the chat logic (e.g., when the AI is generating a response). Animate or style the indicator according to shadcn/ui guidelines.",
            "status": "done",
            "testStrategy": "Trigger typing events (e.g., simulate AI response delay) and verify that the typing indicator appears and disappears at the correct times."
          },
          {
            "id": 5,
            "title": "Apply shadcn/ui Design and Accessibility Standards",
            "description": "Ensure the entire CustomChat component adheres to shadcn/ui design guidelines, including theming, spacing, and accessibility best practices.",
            "dependencies": [
              "3.2",
              "3.3",
              "3.4"
            ],
            "details": "Review the component's layout, colors, spacing, and typography to ensure consistency with shadcn/ui. Implement dark/light mode support if required. Add ARIA attributes and keyboard navigation for accessibility. Refactor styles to use shadcn/ui primitives where possible.",
            "status": "done",
            "testStrategy": "Compare the UI against shadcn/ui reference designs, test in both light and dark modes, and use accessibility tools to validate ARIA and keyboard support."
          }
        ]
      },
      {
        "id": 4,
        "title": "Create useTypebotChat Hook for Conversation Logic",
        "description": "Implement useTypebotChat.ts to encapsulate chat logic, including API calls and session management.",
        "details": "Abstract logic for starting and continuing chats with Typebot. Manage sessionId, handle message sending, and expose state for UI components.",
        "testStrategy": "Unit test the hook for correct API call sequences, session management, and error handling. Mock API responses to simulate chat flow.",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Hook State and Types",
            "description": "Establish the TypeScript types and initial state structure for the useTypebotChat hook, including sessionId, messages, loading, and error states.",
            "dependencies": [],
            "details": "Create TypeScript interfaces/types for chat messages, session state, and hook return values. Initialize state variables using React's useState for sessionId, messages, loading, and error. Ensure the state structure supports both chat initialization and ongoing conversation management.",
            "status": "pending",
            "testStrategy": "Write unit tests to verify that the initial state and types are correctly set and that the hook returns the expected structure."
          },
          {
            "id": 2,
            "title": "Implement Session Management Logic",
            "description": "Add logic to start a new chat session and persist the sessionId for subsequent API calls.",
            "dependencies": [
              "4.1"
            ],
            "details": "Implement a function to initiate a chat session with the Typebot API, storing the returned sessionId in state. Ensure sessionId is reused for ongoing conversations and reset appropriately when starting a new chat.",
            "status": "pending",
            "testStrategy": "Mock the session start API and verify that sessionId is set and reused correctly across hook invocations."
          },
          {
            "id": 3,
            "title": "Implement Message Sending and Receiving",
            "description": "Add functions to send user messages to the Typebot API and handle incoming responses, updating the chat state accordingly.",
            "dependencies": [
              "4.2"
            ],
            "details": "Create a sendMessage function that posts user input to the Typebot API using the current sessionId. Update the messages state with both user and bot messages. Handle loading and error states during API calls.",
            "status": "pending",
            "testStrategy": "Mock message send/receive APIs, test message flow, and ensure state updates correctly for both user and bot messages."
          },
          {
            "id": 4,
            "title": "Expose Hook API and State for UI Integration",
            "description": "Design the hook's return value to expose state and actions needed by UI components, such as messages, loading, error, sendMessage, and session management functions.",
            "dependencies": [
              "4.3"
            ],
            "details": "Return an object from the hook containing the current messages, loading and error states, sendMessage function, and any session control methods. Ensure the API is intuitive and covers all UI integration needs.",
            "status": "pending",
            "testStrategy": "Write tests to confirm that the hook's API exposes all required properties and functions, and that state updates propagate as expected."
          },
          {
            "id": 5,
            "title": "Add Comprehensive Unit Tests and Mock API Integration",
            "description": "Develop unit tests for all hook logic, including session management, message flow, error handling, and state exposure, using mocked API responses.",
            "dependencies": [
              "4.4"
            ],
            "details": "Use a testing library (e.g., React Testing Library, Jest) to simulate chat flows, session resets, and error scenarios. Mock all API calls to ensure tests are deterministic and cover edge cases.",
            "status": "pending",
            "testStrategy": "Ensure all logic branches are tested, including successful and failed API calls, session resets, and state updates. Achieve high code coverage for the hook."
          }
        ]
      },
      {
        "id": 5,
        "title": "Develop typebotApiService for Typebot API Communication",
        "description": "Centralize all Typebot API calls in typebotApiService.ts, including /startChat and /continueChat endpoints.",
        "details": "Implement functions for starting a chat (sending caso_id, user_id, nombre, email, context) and continuing a chat (using sessionId). Handle API errors and return structured responses.",
        "testStrategy": "Write integration tests for each API function, including success and failure scenarios. Validate payload structure and error propagation.",
        "priority": "high",
        "dependencies": [
          4
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Typebot API Request and Response Types",
            "description": "Create TypeScript interfaces for the request payloads and response structures for /startChat and /continueChat endpoints.",
            "dependencies": [],
            "details": "Analyze the expected payloads and responses for both endpoints. Define interfaces such as StartChatRequest, StartChatResponse, ContinueChatRequest, and ContinueChatResponse in a dedicated types file. Ensure all required fields (caso_id, user_id, nombre, email, context, sessionId) are represented and responses are structured for error handling.",
            "status": "pending",
            "testStrategy": "Validate type definitions by writing unit tests that check type compatibility and ensure all required fields are present."
          },
          {
            "id": 2,
            "title": "Implement startChat Function",
            "description": "Develop the startChat function in typebotApiService.ts to initiate a chat session by sending the required payload to the /startChat endpoint.",
            "dependencies": [
              "5.1"
            ],
            "details": "Use the defined StartChatRequest type to construct the payload. Implement the function to make an HTTP POST request to /startChat, handle API errors, and return a structured StartChatResponse. Use async/await and try/catch for error management. Ensure the function accepts caso_id, user_id, nombre, email, and context as parameters.",
            "status": "pending",
            "testStrategy": "Write integration tests to verify correct payload transmission, successful chat initiation, and proper error handling for failed requests."
          },
          {
            "id": 3,
            "title": "Implement continueChat Function",
            "description": "Develop the continueChat function in typebotApiService.ts to continue an existing chat session using sessionId.",
            "dependencies": [
              "5.1"
            ],
            "details": "Use the ContinueChatRequest type to construct the payload. Implement the function to make an HTTP POST request to /continueChat, handle API errors, and return a structured ContinueChatResponse. Ensure the function accepts sessionId and any additional required parameters.",
            "status": "pending",
            "testStrategy": "Write integration tests to verify correct session continuation, payload structure, and error propagation for failed requests."
          },
          {
            "id": 4,
            "title": "Centralize Error Handling and Response Formatting",
            "description": "Create a shared error handling and response formatting utility to standardize API error management and response structures across all Typebot API functions.",
            "dependencies": [
              "5.2",
              "5.3"
            ],
            "details": "Implement a utility function (e.g., handleApiError) that processes errors from API calls and formats them into a consistent structure. Ensure both startChat and continueChat functions use this utility for error handling and response formatting. Document the error structure for consumers of typebotApiService.",
            "status": "pending",
            "testStrategy": "Test error scenarios for both API functions to confirm standardized error responses and correct propagation of error details."
          },
          {
            "id": 5,
            "title": "Write Comprehensive Integration Tests for typebotApiService",
            "description": "Develop integration tests covering all API functions, including success and failure scenarios, payload validation, and error propagation.",
            "dependencies": [
              "5.2",
              "5.3",
              "5.4"
            ],
            "details": "Use a testing framework (e.g., Jest) to write tests for startChat and continueChat functions. Mock API endpoints to simulate various responses. Validate that payloads match the defined types, responses are correctly structured, and errors are handled as expected. Include edge cases and invalid input scenarios.",
            "status": "pending",
            "testStrategy": "Run all tests and ensure coverage for both endpoints, error handling, and payload validation. Review test results for completeness and reliability."
          }
        ]
      },
      {
        "id": 6,
        "title": "Integrate Supabase Edge Function for Case Creation",
        "description": "Invoke crear-borrador-caso Edge Function with user_id when the initial query is submitted.",
        "details": "Call the Supabase Edge Function from NuevaConsultaSection after the user submits the initial form. Store the returned caso_id for subsequent operations.",
        "testStrategy": "Mock the Edge Function and verify that it is called with correct parameters. Ensure caso_id is correctly handled and passed to downstream logic.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configure Supabase Client for Edge Function Invocation",
            "description": "Set up the Supabase client in the frontend to securely invoke Edge Functions, ensuring authentication headers are included.",
            "dependencies": [],
            "details": "Install the Supabase JS client if not already present. Initialize the client with your project's URL and anon/public key. Ensure the client is configured to send the user's JWT in the Authorization header when invoking Edge Functions, as required for authentication and authorization.",
            "status": "pending",
            "testStrategy": "Verify that the client is initialized correctly and that requests to Edge Functions include the necessary headers."
          },
          {
            "id": 2,
            "title": "Implement Edge Function Invocation Logic in NuevaConsultaSection",
            "description": "Add logic to NuevaConsultaSection to invoke the crear-borrador-caso Edge Function with the user_id when the initial query form is submitted.",
            "dependencies": [
              "6.1"
            ],
            "details": "On form submission, construct a POST request to the crear-borrador-caso Edge Function endpoint using the Supabase client. Pass the user_id and any required payload fields in the request body. Handle the asynchronous response and errors appropriately.",
            "status": "pending",
            "testStrategy": "Mock the Edge Function endpoint and verify that it is called with the correct payload and headers when the form is submitted."
          },
          {
            "id": 3,
            "title": "Handle Edge Function Response and Store caso_id",
            "description": "Process the response from the Edge Function and store the returned caso_id in component state for downstream use.",
            "dependencies": [
              "6.2"
            ],
            "details": "Extract the caso_id from the Edge Function's JSON response. Store it in React state or context within NuevaConsultaSection. Ensure error handling for cases where the response is malformed or missing caso_id.",
            "status": "pending",
            "testStrategy": "Simulate various Edge Function responses and verify that caso_id is correctly extracted and stored, and errors are handled gracefully."
          },
          {
            "id": 4,
            "title": "Integrate caso_id into Downstream Logic and UI Flow",
            "description": "Ensure that the stored caso_id is passed to subsequent components and logic, such as chat initialization and file attachment workflows.",
            "dependencies": [
              "6.3"
            ],
            "details": "Update the NuevaConsultaSection and any child components to accept caso_id as a prop or via context. Use caso_id for initializing chat sessions, associating file uploads, and any other case-specific operations.",
            "status": "pending",
            "testStrategy": "Test that downstream components receive the correct caso_id and that workflows dependent on caso_id function as expected."
          },
          {
            "id": 5,
            "title": "Implement Comprehensive Testing and Error Handling",
            "description": "Develop unit and integration tests for the Edge Function invocation flow, including error scenarios and edge cases.",
            "dependencies": [
              "6.4"
            ],
            "details": "Write tests to mock the Edge Function, simulate network errors, invalid responses, and authorization failures. Ensure that the UI provides clear feedback to users in all scenarios and that the caso_id is reliably managed throughout the flow.",
            "status": "pending",
            "testStrategy": "Run automated tests covering successful invocation, error handling, and UI feedback. Manually test the flow in development to confirm robustness."
          }
        ]
      },
      {
        "id": 7,
        "title": "Implement File Upload to Supabase Storage",
        "description": "Enable file selection and upload to Supabase Storage in a path associated with caso_id, showing upload progress.",
        "details": "Use PromptInputActionAddAttachments for file selection. Upload files to Supabase Storage at casos/{caso_id}/adjuntos/. Display upload progress and handle errors. Return URLs of uploaded files.",
        "testStrategy": "Test file selection, upload, and progress indicator. Validate that files are uploaded to the correct path and URLs are returned. Simulate upload failures to test error handling.",
        "priority": "high",
        "dependencies": [
          6
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Integrate File Selection Using PromptInputActionAddAttachments",
            "description": "Implement the UI and logic for users to select one or more files for upload using PromptInputActionAddAttachments.",
            "dependencies": [],
            "details": "Render the file selection component within the chat or form interface. Ensure it supports multiple file selection and exposes the selected files as a list of File objects. Validate file types and sizes as needed before proceeding to upload.",
            "status": "pending",
            "testStrategy": "Test that users can select single and multiple files. Validate that the selected files are correctly listed and accessible for upload."
          },
          {
            "id": 2,
            "title": "Prepare Supabase Storage Path and Metadata for Upload",
            "description": "Generate the correct Supabase Storage path for each file using the provided caso_id, and prepare any necessary metadata.",
            "dependencies": [
              "7.1"
            ],
            "details": "For each selected file, construct the storage path as 'casos/{caso_id}/adjuntos/{filename}'. Ensure caso_id is available and valid. Optionally, prepare metadata such as content type for each file.",
            "status": "pending",
            "testStrategy": "Verify that the generated paths match the expected format and include the correct caso_id and filename. Check that metadata is correctly assigned."
          },
          {
            "id": 3,
            "title": "Implement File Upload to Supabase Storage with Progress Tracking",
            "description": "Upload each selected file to Supabase Storage at the prepared path, displaying real-time upload progress to the user.",
            "dependencies": [
              "7.2"
            ],
            "details": "Use the supabase-js SDK's upload method for each file, passing the bucket name, path, and file object. Implement progress tracking by listening to upload events or periodically updating progress based on bytes transferred. Handle large files using resumable or multipart upload if needed.",
            "status": "pending",
            "testStrategy": "Upload files of varying sizes and verify that progress is displayed accurately. Simulate slow network conditions to test progress updates."
          },
          {
            "id": 4,
            "title": "Handle Upload Errors and Provide User Feedback",
            "description": "Detect and handle errors during file upload, displaying clear error messages and allowing retry or cancellation.",
            "dependencies": [
              "7.3"
            ],
            "details": "Catch errors from the upload process, such as network failures, file size limits, or permission issues. Display user-friendly error messages in the UI. Allow users to retry failed uploads or remove problematic files from the selection.",
            "status": "pending",
            "testStrategy": "Simulate upload failures (e.g., disconnect network, upload oversized files) and confirm that errors are caught and displayed. Test retry and cancellation flows."
          },
          {
            "id": 5,
            "title": "Return Uploaded File URLs and Integrate with Parent Workflow",
            "description": "Collect the URLs of successfully uploaded files and return them to the parent component or workflow for further processing.",
            "dependencies": [
              "7.3",
              "7.4"
            ],
            "details": "After each successful upload, retrieve the public URL or storage reference for the file from Supabase. Aggregate all URLs and pass them to the parent workflow, ensuring only successfully uploaded files are included.",
            "status": "pending",
            "testStrategy": "Verify that the returned URLs are correct and accessible. Test integration with downstream components that consume these URLs."
          }
        ]
      },
      {
        "id": 8,
        "title": "Send Uploaded File URLs to Typebot",
        "description": "Include an 'adjuntos' array with Supabase Storage URLs in the message payload sent to Typebot.",
        "details": "After successful upload, collect file URLs and include them in the adjuntos property of the payload for /startChat and /continueChat calls via typebotApiService.",
        "testStrategy": "Verify that the payload sent to Typebot includes the correct adjuntos array. Check that Typebot receives and processes the file links.",
        "priority": "high",
        "dependencies": [
          5,
          7
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Collect Uploaded File Paths from Supabase Storage",
            "description": "After files are uploaded to Supabase Storage, gather the storage paths or identifiers for each uploaded file.",
            "dependencies": [],
            "details": "Ensure the upload logic returns or stores the file paths (bucket and object key) for each successfully uploaded file. These paths will be used to generate URLs in the next step.",
            "status": "pending",
            "testStrategy": "Upload multiple files and verify that their storage paths are correctly collected and available for further processing."
          },
          {
            "id": 2,
            "title": "Generate Public or Signed URLs for Uploaded Files",
            "description": "Convert the collected Supabase Storage file paths into accessible URLs using either public URLs or signed URLs, depending on bucket permissions.",
            "dependencies": [
              "8.1"
            ],
            "details": "If the bucket is public, use Supabase's getPublicUrl method to generate URLs. If private, use createSignedUrl or createSignedUrls for temporary access. Ensure all URLs are valid and accessible as required by the application context.",
            "status": "pending",
            "testStrategy": "For each file path, verify that the generated URL is accessible and matches the expected format. Test both public and signed URL scenarios."
          },
          {
            "id": 3,
            "title": "Assemble 'adjuntos' Array with File URLs",
            "description": "Create an array named 'adjuntos' containing all generated file URLs to be included in the Typebot message payload.",
            "dependencies": [
              "8.2"
            ],
            "details": "Map each generated file URL into the 'adjuntos' array. Ensure the array structure matches the expected payload schema for Typebot API calls.",
            "status": "pending",
            "testStrategy": "Check that the 'adjuntos' array contains all and only the intended URLs, and that its structure is correct."
          },
          {
            "id": 4,
            "title": "Integrate 'adjuntos' Array into Typebot API Payload",
            "description": "Modify the payload construction logic for /startChat and /continueChat calls to include the 'adjuntos' array with file URLs.",
            "dependencies": [
              "8.3"
            ],
            "details": "Update typebotApiService to accept and inject the 'adjuntos' array into the payload for both chat initiation and continuation endpoints. Ensure backward compatibility if 'adjuntos' is optional.",
            "status": "pending",
            "testStrategy": "Send test payloads to Typebot and verify that the 'adjuntos' array is present and correctly formatted in the outgoing requests."
          },
          {
            "id": 5,
            "title": "Verify End-to-End Delivery and Processing of File URLs by Typebot",
            "description": "Test the full flow to ensure that Typebot receives and processes the 'adjuntos' array as intended, and that file links are usable in the chat context.",
            "dependencies": [
              "8.4"
            ],
            "details": "Perform integration tests simulating user uploads, chat initiation, and continuation. Confirm that Typebot receives the URLs and that they are accessible and displayed or handled as expected in the chat interface.",
            "status": "pending",
            "testStrategy": "Check Typebot's received payloads, confirm file links are functional in the chat, and validate error handling for missing or invalid URLs."
          }
        ]
      },
      {
        "id": 9,
        "title": "Implement Error Handling and User Feedback",
        "description": "Display clear error messages for API failures and file upload issues throughout the chat flow.",
        "details": "Catch and handle errors in all async operations (API calls, uploads). Show user-friendly error messages in the UI. Ensure errors do not break the flow.",
        "testStrategy": "Simulate API and upload failures. Confirm that appropriate error messages are displayed and the UI remains stable.",
        "priority": "medium",
        "dependencies": [
          3,
          5,
          7
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Audit Async Operations for Error Sources",
            "description": "Identify all async operations in the chat flow, including API calls and file uploads, and document where errors may occur.",
            "dependencies": [],
            "details": "Review all code handling API requests and file uploads. List each async operation and specify potential failure points (e.g., network errors, invalid responses, upload timeouts). This audit will inform where error handling logic needs to be implemented.",
            "status": "pending",
            "testStrategy": "Verify the audit covers all async operations by cross-referencing with the chat flow and upload logic."
          },
          {
            "id": 2,
            "title": "Implement Centralized Error Handling Logic",
            "description": "Develop reusable error handling functions for API and upload failures, ensuring all async operations use these handlers.",
            "dependencies": [
              "9.1"
            ],
            "details": "Create error handler utilities (e.g., handleApiError, handleUploadError) that catch exceptions, log errors, and return standardized error objects. Refactor async operations to use these handlers, ensuring consistent error capture and propagation.",
            "status": "pending",
            "testStrategy": "Simulate failures in API and upload operations and confirm that errors are caught and processed by the centralized handlers."
          },
          {
            "id": 3,
            "title": "Design and Implement User-Friendly Error Messages",
            "description": "Create clear, actionable, and context-aware error messages for each error scenario, following best practices for tone and guidance.",
            "dependencies": [
              "9.2"
            ],
            "details": "Draft error messages that explain the issue, avoid blaming the user, and suggest next steps or alternatives. Implement UI components to display these messages in the chat interface and upload dialogs. Use call-to-actions (e.g., retry, contact support) where appropriate.",
            "status": "pending",
            "testStrategy": "Trigger each error scenario and verify that the correct message appears, is understandable, and guides the user effectively."
          },
          {
            "id": 4,
            "title": "Ensure Error Messages Do Not Break Chat Flow",
            "description": "Modify chat and upload UI logic to gracefully handle errors, maintaining conversation continuity and partial functionality where possible.",
            "dependencies": [
              "9.3"
            ],
            "details": "Update UI state management so that errors do not block further user actions. Allow users to retry failed operations, continue chatting, or access alternative features. Implement fallback responses and escalation paths (e.g., offer human support after repeated failures).",
            "status": "pending",
            "testStrategy": "Simulate consecutive errors and confirm that the chat flow remains usable, with options for recovery or escalation."
          },
          {
            "id": 5,
            "title": "Implement Error Logging and Feedback Collection",
            "description": "Log all error events and provide mechanisms for users to submit feedback on error experiences, enabling continuous improvement.",
            "dependencies": [
              "9.4"
            ],
            "details": "Integrate error logging (e.g., to analytics or monitoring services) for all handled errors. Add a feedback prompt after error messages, allowing users to report issues or suggest improvements. Regularly review logs and feedback to identify patterns and refine error handling.",
            "status": "pending",
            "testStrategy": "Verify that errors are logged with sufficient detail and that user feedback submissions are captured and accessible for review."
          }
        ]
      },
      {
        "id": 10,
        "title": "Enforce Supabase Storage RLS Policies for Security",
        "description": "Configure Supabase Storage Row Level Security (RLS) to restrict file uploads to authorized users and their own cases.",
        "details": "Define and test RLS policies so users can only upload and access files in their own casos/{caso_id}/adjuntos/ directories. Document policy logic.",
        "testStrategy": "Attempt uploads and access with various user roles and cases. Ensure unauthorized access is denied and authorized access works as expected.",
        "priority": "high",
        "dependencies": [
          7
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Analyze Storage Structure and User-Case Mapping",
            "description": "Review the Supabase Storage bucket structure and determine how user authentication and caso_id are mapped to storage paths (casos/{caso_id}/adjuntos/).",
            "dependencies": [],
            "details": "Inspect the current storage bucket and directory organization. Confirm that each file is stored under a path that includes the relevant caso_id and that user identity (auth.uid()) can be reliably associated with allowed caso_ids. Document the mapping logic for use in policy expressions.",
            "status": "pending",
            "testStrategy": "Verify that for a given user and caso_id, the expected storage path is generated and accessible in code."
          },
          {
            "id": 2,
            "title": "Enable RLS on storage.objects Table",
            "description": "Ensure Row Level Security is enabled on the storage.objects table to enforce policy checks for all storage operations.",
            "dependencies": [
              "10.1"
            ],
            "details": "In the Supabase dashboard or SQL editor, run the command to enable RLS on the storage.objects table. Confirm that no storage operations are permitted until explicit policies are defined.",
            "status": "pending",
            "testStrategy": "Attempt to upload or access files after enabling RLS but before adding policies; confirm that all operations are denied."
          },
          {
            "id": 3,
            "title": "Define RLS Policies for File Upload and Access",
            "description": "Create RLS policies that allow authenticated users to upload and access files only within their authorized casos/{caso_id}/adjuntos/ directories.",
            "dependencies": [
              "10.2"
            ],
            "details": "Write SQL policies for the storage.objects table:\n- INSERT: Allow only authenticated users to upload files where the path matches casos/{caso_id}/adjuntos/ and the caso_id is authorized for the user.\n- SELECT: Allow only authenticated users to access files in their own casos/{caso_id}/adjuntos/ directories.\nUse expressions referencing auth.uid() and path parsing helpers as needed.",
            "status": "pending",
            "testStrategy": "Test policy logic with various users and caso_ids, ensuring only authorized uploads and access are permitted."
          },
          {
            "id": 4,
            "title": "Test RLS Policies with Multiple User Scenarios",
            "description": "Systematically test the defined RLS policies by simulating uploads and access attempts from users with different roles and case assignments.",
            "dependencies": [
              "10.3"
            ],
            "details": "Create test users and assign them to different cases. Attempt file uploads and downloads to various casos/{caso_id}/adjuntos/ directories, including both authorized and unauthorized scenarios. Log and analyze results to confirm policy enforcement.",
            "status": "pending",
            "testStrategy": "Automate tests where possible. Ensure unauthorized access is denied and authorized access works as expected."
          },
          {
            "id": 5,
            "title": "Document RLS Policy Logic and Security Model",
            "description": "Write clear documentation explaining the RLS policy logic, including how user-case authorization is enforced and how to maintain or extend the policies.",
            "dependencies": [
              "10.4"
            ],
            "details": "Document the SQL policy definitions, the rationale for each policy, and the mapping between user authentication, caso_id, and storage paths. Include guidance for future maintenance and troubleshooting.",
            "status": "pending",
            "testStrategy": "Have a peer review the documentation for clarity and completeness. Ensure it enables future developers to understand and safely modify the policies."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-09-23T08:44:39.748Z",
      "updated": "2025-09-23T10:14:17.757Z",
      "description": "Tasks for feature-chat-dashboard context"
    }
  }
}
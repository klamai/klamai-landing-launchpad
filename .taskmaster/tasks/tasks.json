{
  "master": {
    "tasks": [
      {
        "id": 3,
        "title": "Implement Complete Row Level Security (RLS)",
        "description": "Conduct a comprehensive audit of all database tables and implement strict RLS policies to ensure data access is properly restricted to authorized users only.",
        "details": "1. Create a script to identify all tables in the Supabase database\n2. For each table containing user data or sensitive information:\n   - Review existing RLS policies\n   - Create or update policies for SELECT, INSERT, UPDATE, DELETE operations\n   - Ensure policies follow the principle of least privilege\n3. Implement specific policies based on user roles:\n   - Regular users should only access their own data\n   - Lawyers should only access assigned cases\n   - Admins should have appropriate access controls\n4. Example policy for a user_profiles table:\n```sql\nCREATE POLICY \"Users can view their own profiles\"\nON user_profiles\nFOR SELECT\nUSING (auth.uid() = user_id);\n\nCREATE POLICY \"Users can update their own profiles\"\nON user_profiles\nFOR UPDATE\nUSING (auth.uid() = user_id);\n```\n5. Document all policies in a central security document",
        "testStrategy": "1. Create test cases for each table and policy\n2. Verify access control by attempting unauthorized operations:\n   - Try to access data belonging to other users\n   - Attempt to modify data without proper permissions\n3. Use Supabase's policy simulator to test policies\n4. Create automated tests that verify RLS is working correctly\n5. Document test results and any policy adjustments made",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Fix PostgreSQL Function Vulnerabilities",
        "description": "Address performance issues in Row Level Security (RLS) policies that have been identified as critical after the search_path vulnerabilities were resolved.",
        "status": "pending",
        "dependencies": [],
        "priority": "high",
        "details": "The original search_path vulnerabilities in the 13 PostgreSQL functions have been fixed. Now we need to focus on optimizing RLS policies:\n\n1. Run `supabase db lint` to identify any remaining issues and focus on RLS policy performance warnings\n2. Analyze each RLS policy for performance bottlenecks, particularly:\n   - Policies with complex joins\n   - Policies without proper indexing\n   - Policies with expensive functions\n3. Create a migration SQL file to optimize the identified RLS policies\n4. For each problematic policy, consider:\n   - Adding appropriate indexes\n   - Simplifying policy expressions\n   - Rewriting policies to use more efficient patterns\n5. Example optimization format:\n```sql\n-- Optimize RLS policy for table_name\nDROP POLICY IF EXISTS policy_name ON table_name;\nCREATE POLICY policy_name ON table_name\nFOR operation\nTO role\nUSING (optimized_expression);\n\n-- Add supporting index if needed\nCREATE INDEX IF NOT EXISTS idx_name ON table_name(columns);\n```\n6. Apply the migration to both local and cloud environments\n7. Document all changes made to the policies and their performance impact",
        "testStrategy": "1. Benchmark performance before and after policy changes\n2. Create test cases that specifically target the optimized policies\n3. Use EXPLAIN ANALYZE to verify query plans are using indexes properly\n4. Test with realistic data volumes to ensure optimizations are effective\n5. Monitor query performance in development environment before deploying to production\n6. Document performance improvements with metrics\n7. Include RLS policy performance checks in CI/CD pipeline",
        "subtasks": [
          {
            "id": 1,
            "title": "Document resolution of search_path vulnerabilities",
            "description": "Create documentation noting that the original 13 PostgreSQL functions with mutable search_path issues have been fixed. Include the list of functions that were affected and how they were resolved.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Identify problematic RLS policies",
            "description": "Run performance analysis to identify RLS policies causing performance issues. Create a prioritized list of policies that need optimization.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Create optimization plan for each policy",
            "description": "For each identified problematic policy, document the current implementation, performance issues, and proposed optimization approach.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement RLS policy optimizations",
            "description": "Create migration files with optimized RLS policies and supporting indexes.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Performance testing",
            "description": "Create and run benchmarks to measure performance improvements from the optimized policies.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 5,
        "title": "Implement Rate Limiting",
        "description": "Configure rate limiting on authentication endpoints and other critical API functions to protect against brute force attacks and API abuse.",
        "details": "1. Access Supabase dashboard and navigate to Authentication settings\n2. Configure rate limiting for the following operations:\n   - Login attempts (e.g., 5 attempts per minute)\n   - Password reset requests (e.g., 3 requests per hour)\n   - User registration (e.g., 3 registrations per hour per IP)\n   - API key usage (appropriate limits based on expected usage)\n3. For custom API endpoints, implement rate limiting using middleware:\n```javascript\n// Example using Express Rate Limit middleware\nconst rateLimit = require('express-rate-limit');\n\nconst authLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 5, // 5 requests per windowMs\n  message: 'Too many authentication attempts, please try again later'\n});\n\napp.use('/api/auth/', authLimiter);\n```\n4. Implement appropriate client-side handling of rate limit responses\n5. Add monitoring for rate limit events",
        "testStrategy": "1. Create automated tests that attempt to exceed rate limits\n2. Verify that rate limiting correctly blocks excessive requests\n3. Test client-side handling of rate limit responses\n4. Simulate various attack scenarios to ensure protection\n5. Monitor rate limit events in production to fine-tune limits as needed",
        "priority": "medium",
        "dependencies": [
          3,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Create Audit Trail System",
        "description": "Develop a comprehensive audit logging system to track security events, user actions, and data access for compliance with GDPR and security incident response.",
        "details": "1. Create a new `audit_log` table in Supabase:\n```sql\nCREATE TABLE audit_log (\n  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n  user_id UUID REFERENCES auth.users(id),\n  action TEXT NOT NULL,\n  table_name TEXT,\n  record_id TEXT,\n  old_data JSONB,\n  new_data JSONB,\n  ip_address TEXT,\n  user_agent TEXT,\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n);\n```\n2. Create PostgreSQL triggers for critical tables to automatically log changes:\n```sql\nCREATE OR REPLACE FUNCTION log_audit_event()\nRETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO audit_log (user_id, action, table_name, record_id, old_data, new_data)\n  VALUES (auth.uid(), TG_OP, TG_TABLE_NAME, NEW.id, \n          CASE WHEN TG_OP = 'DELETE' THEN to_jsonb(OLD) ELSE NULL END,\n          CASE WHEN TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN to_jsonb(NEW) ELSE NULL END);\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n```\n3. Apply triggers to relevant tables\n4. Implement frontend logging for authentication events:\n   - Login attempts (successful and failed)\n   - Password changes\n   - Profile updates\n   - Permission changes\n5. Create an admin interface to view and filter audit logs\n6. Implement GDPR-compliant data retention policies for logs",
        "testStrategy": "1. Test automatic logging by performing various database operations\n2. Verify that all required fields are properly captured\n3. Test authentication event logging\n4. Create test cases for each type of auditable action\n5. Verify that sensitive data is properly handled in logs\n6. Test the admin interface for viewing logs\n7. Verify that logs are retained according to policy",
        "priority": "medium",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Configure Leaked Password Protection",
        "description": "Enable Supabase's leaked password protection feature to check user passwords against known compromised password databases like HaveIBeenPwned.",
        "details": "1. Evaluate Supabase pricing plans that include leaked password protection\n2. Once upgraded to an appropriate plan:\n   - Access Supabase dashboard\n   - Navigate to Authentication settings\n   - Enable the 'Leaked Password Protection' feature\n3. Configure the feature to check passwords during:\n   - New user registration\n   - Password changes\n   - Password resets\n4. Implement appropriate error messages in the frontend:\n```javascript\n// Example React component handling leaked password error\nconst handleSignUp = async (email, password) => {\n  try {\n    const { error } = await supabase.auth.signUp({ email, password });\n    if (error) {\n      if (error.message.includes('leaked password')) {\n        setError('This password has been found in a data breach. Please choose a different password.');\n      } else {\n        setError(error.message);\n      }\n    }\n  } catch (error) {\n    setError('An unexpected error occurred');\n  }\n};\n```\n5. Document the feature in user documentation",
        "testStrategy": "1. Test with known compromised passwords to verify detection\n2. Verify that appropriate error messages are displayed\n3. Test password change and reset flows\n4. Ensure the feature doesn't block valid, secure passwords\n5. Monitor user feedback after implementation",
        "priority": "low",
        "dependencies": [
          3,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Plan External Security Audit",
        "description": "Prepare for and coordinate an external security audit (penetration testing) to identify potential vulnerabilities in the application once it reaches a mature state.",
        "details": "1. Research and evaluate security audit providers specializing in web applications and Supabase\n2. Create a comprehensive scope document for the audit, including:\n   - Authentication system\n   - Authorization and access controls\n   - API endpoints\n   - Database security\n   - Frontend security\n   - Infrastructure security\n3. Prepare a budget proposal with cost estimates from 3-5 providers\n4. Create a timeline for the audit process:\n   - Pre-audit preparation\n   - Audit execution (typically 1-2 weeks)\n   - Remediation period\n   - Re-testing\n5. Develop a security documentation package for auditors:\n   - System architecture\n   - Authentication flows\n   - Data models\n   - Security controls already in place\n6. Create a plan for addressing findings post-audit",
        "testStrategy": "1. Conduct an internal pre-audit using tools like OWASP ZAP\n2. Create a checklist of security best practices to verify before the external audit\n3. Develop a process for tracking and prioritizing audit findings\n4. Plan for verification testing after remediation\n5. Create a template for documenting audit results and actions taken",
        "priority": "low",
        "dependencies": [
          3,
          4,
          5,
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Optimize RLS Policies for Performance Improvement",
        "description": "Optimize 50+ Row Level Security (RLS) policies that are causing critical performance issues by refactoring auth function calls and consolidating duplicate policies.",
        "details": "1. Identify all RLS policies that are causing performance issues:\n   - Run `supabase db lint` to identify RLS policies with performance warnings\n   - Use `pg_stat_statements` to identify the slowest queries related to RLS policies\n   - Review all policies that call auth functions directly in the policy definition\n\n2. Refactor RLS policies to optimize auth function calls:\n   - Replace direct auth function calls in row-level evaluations with subqueries\n   - Example transformation:\n     ```sql\n     -- Before (inefficient - evaluates for each row)\n     CREATE POLICY \"Users can view their own data\" ON \"public\".\"profiles\"\n       USING (auth.uid() = user_id);\n       \n     -- After (optimized - evaluates once per query)\n     CREATE POLICY \"Users can view their own data\" ON \"public\".\"profiles\"\n       USING ((SELECT auth.uid()) = user_id);\n     ```\n\n3. Consolidate duplicate or overlapping policies:\n   - Identify tables with multiple similar policies that can be combined\n   - Create a spreadsheet to track all policies, their purpose, and consolidation opportunities\n   - Develop a migration plan that ensures no security gaps during transition\n\n4. Create database migration files:\n   - For each table with policies to optimize, create DROP and CREATE statements\n   - Group related policy changes in logical migration files\n   - Include comments explaining the performance optimization rationale\n\n5. Prioritize optimization based on impact:\n   - Focus first on policies applied to tables with the highest query volume\n   - Address policies on tables with the largest row counts\n   - Optimize policies on tables that are frequently joined in complex queries\n\n6. Document performance metrics:\n   - Record baseline query times before optimization\n   - Document the optimization approach for each policy\n   - Create a summary of expected performance improvements",
        "testStrategy": "1. Create a comprehensive test suite that verifies security is maintained:\n   - Develop test cases that verify all access patterns still work correctly\n   - Include negative test cases to ensure unauthorized access is still prevented\n   - Test edge cases like null values, empty results, and boundary conditions\n\n2. Measure and compare performance metrics:\n   - Use EXPLAIN ANALYZE to compare query plans before and after optimization\n   - Benchmark query execution times with realistic data volumes\n   - Test with concurrent users to measure overall system performance improvement\n   - Document performance improvements for each optimized policy\n\n3. Implement automated regression tests:\n   - Create automated tests that verify all security rules are still enforced\n   - Include these tests in the CI/CD pipeline\n   - Ensure tests cover all tables with modified RLS policies\n\n4. Perform load testing:\n   - Simulate high traffic scenarios to verify performance under load\n   - Compare server resource utilization before and after optimization\n   - Verify that database connection pool is not exhausted under load\n\n5. Monitor in staging environment:\n   - Deploy changes to staging environment first\n   - Monitor query performance for at least 24 hours\n   - Check for any unexpected behavior or performance regressions",
        "status": "pending",
        "dependencies": [
          4
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "[Frontend] Crear Página de Solicitud para Abogados (`/abogados/solicitud`)",
        "description": "Diseñar y maquetar la interfaz de usuario para el formulario de solicitud de nuevos abogados en la ruta `/abogados/solicitud`. Debe ser profesional, atractiva y consistente con el diseño general del sitio.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "[Frontend] Implementar Formulario de Solicitud con Validación",
        "description": "Implementar el formulario completo con todos los campos de la tabla `solicitudes_abogado`. Incluir validación de campos en el frontend (ej. con Zod y React Hook Form) y un componente de selección múltiple para las especialidades, cargadas dinámicamente desde la base de datos.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "[Frontend] Implementar Subida Segura de Archivos",
        "description": "Crear un componente de frontend que permita a los usuarios subir de forma segura sus documentos de verificación (DNI, carnet de colegiado, etc.) directamente a un bucket de Supabase Storage. Debe manejar estados de carga, éxito y error.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "[Backend] Crear Edge Function `crear-solicitud-abogado`",
        "description": "Desarrollar una nueva Supabase Edge Function que sirva como endpoint seguro para recibir los datos del formulario de solicitud. Debe estar configurada para aceptar únicamente peticiones POST.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "[Backend] Implementar Lógica de Inserción y Auditoría (RGPD)",
        "description": "Dentro de la Edge Function, añadir la lógica para validar y sanitizar todos los datos recibidos. Luego, insertar la solicitud en la tabla `solicitudes_abogado`. Inmediatamente después, registrar el evento de consentimiento en la tabla `auditoria_seguridad` para cumplir con RGPD.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          4
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "[Integración] Conectar Frontend con Edge Function",
        "description": "Utilizar React Query (useMutation) en el componente del formulario para enviar los datos a la nueva Edge Function `crear-solicitud-abogado`. Gestionar adecuadamente los estados de carga, éxito y error para proporcionar feedback al usuario.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          3,
          5
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 16,
        "title": "[Testing] Realizar Pruebas E2E del Flujo de Solicitud",
        "description": "Realizar pruebas completas del flujo de solicitud. Esto incluye enviar formularios con datos válidos e inválidos, verificar la subida de archivos, y confirmar que los registros se crean correctamente en `solicitudes_abogado` y `auditoria_seguridad` en la base de datos.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          6
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 17,
        "title": "Fase 1: Implementar Migración de BD para Kanban",
        "description": "Crear un nuevo tipo ENUM en la base de datos llamado etapa_kanban_enum y añadir una nueva columna llamada `etapa` a la tabla `casos`. Esta columna utilizará el nuevo ENUM y tendrá un valor por defecto. Todo esto se gestionará a través de un nuevo archivo de migración de Supabase.",
        "details": "",
        "testStrategy": "Verificar que la migración se aplica correctamente en el entorno local de Supabase y que la nueva columna `etapa` existe en la tabla `casos` con el tipo y valor por defecto correctos.",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 18,
        "title": "Fase 2: Instalar Librería y Crear Componente Kanban",
        "description": "Instalar la librería `shadcn-kanban-board` usando el comando `npx shadcn@latest add ...` y crear el archivo para el nuevo componente `KanbanBoard.tsx` en la estructura de componentes del frontend. El componente debe renderizar una estructura básica con columnas fijas que representen las etapas del Kanban.",
        "details": "",
        "testStrategy": "Verificar que la librería se instala correctamente y que el nuevo componente `KanbanBoard.tsx` se renderiza sin errores en la aplicación, mostrando las columnas vacías.",
        "status": "done",
        "dependencies": [
          17
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 19,
        "title": "Fase 2: Conectar Kanban con Datos de Supabase",
        "description": "En el componente `KanbanBoard.tsx`, implementar una función para llamar a Supabase y obtener todos los casos asignados al abogado actual. Los datos recuperados se deben procesar y utilizar para renderizar los componentes `CaseCard` dentro de las columnas correspondientes del tablero Kanban, según su valor en el nuevo campo `etapa`.",
        "details": "",
        "testStrategy": "Verificar que el tablero Kanban muestra correctamente los `CaseCard` en sus columnas respectivas. Probar con casos en diferentes `etapas` para asegurar que la distribución es correcta.",
        "status": "done",
        "dependencies": [
          18
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 20,
        "title": "Fase 3: Crear RPC para Actualizar Etapa del Caso",
        "description": "Crear una nueva función de base de datos (RPC) en Supabase llamada `actualizar_etapa_caso`. Esta función recibirá un `caso_id` y una `nueva_etapa` como parámetros. Implementará la lógica para verificar los permisos del usuario (debe ser el abogado asignado o un admin) antes de actualizar la columna `etapa` del caso correspondiente en la base de datos.",
        "details": "",
        "testStrategy": "Probar la función RPC directamente desde el editor SQL de Supabase para asegurar que actualiza la etapa correctamente cuando los permisos son válidos y devuelve un error cuando no lo son.",
        "status": "done",
        "dependencies": [
          17
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 21,
        "title": "Fase 3: Implementar Lógica Drag and Drop en Frontend",
        "description": "En `KanbanBoard.tsx`, configurar la lógica de `dnd-kit`. Al detectar el evento `onDragEnd`, se debe obtener el `caso_id` y la `nueva_etapa` (la columna de destino). Luego, invocar la función RPC `actualizar_etapa_caso` de Supabase. Implementar una actualización optimista de la UI para una experiencia fluida.",
        "details": "",
        "testStrategy": "Arrastrar un `CaseCard` a una nueva columna y verificar en la base de datos que el campo `etapa` se ha actualizado correctamente. Asegurarse de que la UI refleja el cambio de forma inmediata y persistente.",
        "status": "done",
        "dependencies": [
          19,
          20
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 22,
        "title": "Fase 4: Mejoras de UI/UX para Kanban (Post-MVP)",
        "description": "Una vez que el tablero Kanban sea completamente funcional, añadir funcionalidades adicionales para mejorar la experiencia del usuario. Esto incluye: 1. Controles de filtro en la UI para buscar casos por cliente o prioridad. 2. Indicadores visuales en las `CaseCard` (ej. para urgencia o notificaciones). 3. Una nueva vista o página para consultar los casos archivados (aquellos en etapa `finalizado`).",
        "details": "",
        "testStrategy": "Verificar que los filtros funcionan correctamente y que los nuevos indicadores visuales se muestran según la lógica definida. Comprobar que la vista de archivo solo muestra los casos finalizados.",
        "status": "pending",
        "dependencies": [
          21
        ],
        "priority": "low",
        "subtasks": []
      },
      {
        "id": 23,
        "title": "[Pago Anónimo] Modificar Base de Datos",
        "description": "Crear una migración de Supabase para añadir la columna 'token_reclamacion_pago' a la tabla 'casos' y el estado 'pago_realizado_pendiente_registro' al ENUM 'caso_estado_enum'.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 24,
        "title": "[Pago Anónimo] Crear Edge Function de Checkout",
        "description": "Crear una nueva Supabase Edge Function llamada 'crear-sesion-checkout-anonima' que reciba un 'caso_id', cree una sesión de Stripe con el 'caso_id' en los metadatos y devuelva la URL de pago.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          23
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 25,
        "title": "[Pago Anónimo] Refactorizar Webhook de Stripe",
        "description": "Refactorizar la función 'stripe-webhook' para manejar el evento 'checkout.session.completed' de pagos anónimos. Debe crear un usuario si no existe (o vincularlo si ya existe) y enviar un email con un enlace para establecer la contraseña.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          23
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 26,
        "title": "[Pago Anónimo] Implementar Flujo en Frontend",
        "description": "Modificar Chat.tsx para que al hacer clic en 'Pagar Consulta' se llame a la nueva función 'crear-sesion-checkout-anonima' y se redirija al usuario a Stripe. Crear una nueva página '/pago-exitoso' para mostrar un mensaje de confirmación post-pago.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          24
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 27,
        "title": "[Pago Anónimo] Pruebas Integrales del Nuevo Flujo",
        "description": "Realizar pruebas de extremo a extremo del nuevo flujo. Verificar el pago anónimo, la creación automática de la cuenta, la recepción del email para establecer contraseña y la correcta vinculación del caso a la nueva cuenta. Probar también el caso de un usuario ya existente.",
        "details": "",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [
          25,
          26
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 28,
        "title": "[Propuesta Pública] Crear Edge Function 'crear-sesion-checkout-propuesta-publica'",
        "description": "Desarrollar una nueva Supabase Edge Function que cree sesiones de checkout en Stripe para usuarios que desean pagar por una consulta después de ver una propuesta pública, incluyendo el origen 'propuesta_publica' en los metadatos.",
        "details": "Esta función debe seguir un patrón similar a la función 'crear-sesion-checkout-anonima' pero adaptada al flujo específico de propuestas públicas:\n\n1. Crear un nuevo archivo en `/supabase/functions/crear-sesion-checkout-propuesta-publica/index.ts`\n2. Configurar CORS y validación de solicitudes POST\n3. Implementar la lógica para:\n   - Recibir el ID de la propuesta pública como parámetro\n   - Validar que la propuesta existe y está disponible para pago\n   - Obtener los detalles necesarios de la propuesta (precio, título, etc.)\n   - Crear una sesión de checkout en Stripe con:\n     - El precio correspondiente a una consulta\n     - Metadatos que incluyan `propuesta_id`, `flujo_origen: 'propuesta_publica'` y cualquier otro dato relevante\n   - Configurar URLs de éxito y cancelación apropiadas\n4. Devolver la URL de la sesión de checkout para redireccionar al usuario\n5. Implementar manejo de errores adecuado con mensajes claros\n6. Documentar la función con comentarios explicativos\n7. Asegurar que la función esté protegida con las políticas de seguridad adecuadas\n\nLa función debe integrarse con el sistema existente de pagos y seguir las mismas prácticas de seguridad y auditoría.",
        "testStrategy": "1. Pruebas unitarias:\n   - Verificar que la función rechaza métodos que no sean POST\n   - Comprobar que valida correctamente los parámetros de entrada\n   - Verificar el manejo de errores cuando la propuesta no existe\n\n2. Pruebas de integración:\n   - Crear una propuesta pública de prueba\n   - Invocar la función con el ID de la propuesta\n   - Verificar que devuelve una URL de Stripe válida\n   - Comprobar que los metadatos incluyen `flujo_origen: 'propuesta_publica'`\n   - Verificar que la sesión de Stripe se crea con el precio correcto\n\n3. Pruebas de extremo a extremo:\n   - Completar un flujo de pago real usando la URL generada\n   - Verificar que el webhook de Stripe procesa correctamente el pago\n   - Comprobar que el sistema actualiza el estado de la propuesta/consulta adecuadamente\n\n4. Pruebas de seguridad:\n   - Intentar acceder a la función sin autenticación adecuada\n   - Verificar que no se pueden manipular los precios o metadatos",
        "status": "pending",
        "dependencies": [
          24,
          25
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 29,
        "title": "[Frontend] Modificar Componente de Propuestas Públicas para Implementar Pago Directo",
        "description": "Identificar y modificar el componente frontend que muestra las propuestas públicas para implementar el flujo de pago directo, cambiando el botón \"Pagar Consulta\" para usar la nueva función Edge.",
        "details": "Esta tarea implica modificar el componente de propuestas públicas para implementar un flujo de pago directo:\n\n1. Identificar el componente o componentes que muestran las propuestas públicas (probablemente en la carpeta `/components/propuestas/` o similar).\n\n2. Localizar el botón \"Pagar Consulta\" actual que abre el modal de registro.\n\n3. Modificar la funcionalidad del botón para:\n   - Eliminar la apertura del modal de registro\n   - Implementar una llamada a la nueva función Edge 'crear-sesion-checkout-propuesta-publica'\n   - Pasar el ID de la propuesta pública como parámetro a la función\n   - Capturar la respuesta que contiene la URL de la sesión de checkout de Stripe\n   - Redirigir al usuario directamente a la URL de Stripe\n\n4. Código de ejemplo para la implementación:\n```tsx\n// Antes\nconst handlePaymentClick = () => {\n  setShowRegistrationModal(true);\n};\n\n// Después\nconst handlePaymentClick = async (propuestaId: string) => {\n  try {\n    setIsLoading(true);\n    const response = await fetch(\n      `${process.env.NEXT_PUBLIC_SUPABASE_URL}/functions/v1/crear-sesion-checkout-propuesta-publica`,\n      {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY}`\n        },\n        body: JSON.stringify({ propuesta_id: propuestaId })\n      }\n    );\n    \n    if (!response.ok) {\n      throw new Error('Error al crear la sesión de checkout');\n    }\n    \n    const { url } = await response.json();\n    window.location.href = url;\n  } catch (error) {\n    console.error('Error:', error);\n    toast.error('Ocurrió un error al procesar el pago. Por favor, inténtalo de nuevo.');\n  } finally {\n    setIsLoading(false);\n  }\n};\n```\n\n5. Añadir un estado de carga para mejorar la experiencia de usuario:\n```tsx\nconst [isLoading, setIsLoading] = useState(false);\n\n// En el botón\n<Button \n  onClick={() => handlePaymentClick(propuesta.id)} \n  disabled={isLoading}\n>\n  {isLoading ? 'Procesando...' : 'Pagar Consulta'}\n</Button>\n```\n\n6. Asegurarse de que la redirección a la página de éxito después del pago funcione correctamente con el nuevo flujo.",
        "testStrategy": "1. Pruebas de componente:\n   - Verificar que el botón \"Pagar Consulta\" ya no abre el modal de registro\n   - Comprobar que al hacer clic en el botón se realiza la llamada a la función Edge con los parámetros correctos\n   - Verificar que se muestra un estado de carga mientras se procesa la solicitud\n\n2. Pruebas de integración:\n   - Crear una propuesta pública de prueba\n   - Hacer clic en \"Pagar Consulta\" y verificar que se redirige correctamente a la página de checkout de Stripe\n   - Completar un pago de prueba en el entorno de desarrollo de Stripe\n   - Verificar que después del pago se redirige a la página de éxito\n\n3. Pruebas de manejo de errores:\n   - Simular un error en la llamada a la función Edge y verificar que se muestra un mensaje de error apropiado\n   - Comprobar que el botón se habilita nuevamente después de un error\n\n4. Pruebas de experiencia de usuario:\n   - Verificar que la transición entre la aplicación y Stripe es fluida\n   - Comprobar que los mensajes de carga y error son claros y útiles",
        "status": "pending",
        "dependencies": [
          28,
          26
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 30,
        "title": "[Webhook Stripe] Corregir Flujo de Creación de Cuenta para Usuarios Anónimos",
        "description": "Verificar y corregir el flujo de creación de cuenta en el webhook de Stripe para usuarios anónimos, asegurando que se envíe un único email de activación con enlace funcional y que el usuario quede marcado como no confirmado hasta completar el proceso.",
        "details": "Esta tarea implica revisar y corregir el proceso de creación de cuentas en el webhook de Stripe para garantizar un flujo correcto tanto para chat como para propuestas públicas:\n\n1. Revisar el código actual en la función stripe-webhook, específicamente el manejo del evento 'checkout.session.completed' para pagos anónimos.\n\n2. Modificar la lógica de creación de usuarios para:\n   - Establecer explícitamente `email_confirm: false` al crear nuevos usuarios\n   - Generar un enlace de activación personalizado en lugar de usar el flujo estándar de Supabase\n   - Asegurar que el usuario quede marcado como no confirmado hasta que complete el proceso de activación\n\n3. Implementar mecanismos para prevenir la duplicación de emails:\n   - Verificar si ya se ha enviado un email de activación antes de enviar uno nuevo\n   - Implementar un sistema de bloqueo (lock) o verificación de estado para evitar condiciones de carrera\n\n4. Actualizar la plantilla de email para incluir el enlace de activación personalizado:\n   - El enlace debe dirigir a una página específica para completar el registro\n   - Incluir parámetros de seguridad como token de un solo uso y timestamp\n\n5. Revisar y corregir la lógica de vinculación de casos/propuestas al usuario:\n   - Asegurar que los casos se vinculen correctamente al usuario recién creado\n   - Verificar que la información de pago se asocie adecuadamente\n\n6. Implementar logging detallado para facilitar la depuración:\n   - Registrar cada paso del proceso\n   - Capturar errores específicos relacionados con la creación de usuarios y envío de emails",
        "testStrategy": "1. Pruebas unitarias:\n   - Verificar que la función establece correctamente `email_confirm: false` al crear usuarios\n   - Comprobar que el enlace de activación se genera correctamente\n   - Validar que el sistema detecta y previene emails duplicados\n\n2. Pruebas de integración:\n   - Realizar un pago anónimo completo a través del chat y verificar:\n     * Que se crea el usuario correctamente en estado no confirmado\n     * Que se envía un único email con el enlace de activación\n     * Que al usar el enlace, la cuenta se activa correctamente\n   - Realizar un pago anónimo a través de una propuesta pública y verificar el mismo flujo\n   - Probar el escenario donde un usuario intenta pagar dos veces (verificar que no se envían emails duplicados)\n\n3. Pruebas de borde:\n   - Verificar el comportamiento cuando hay errores de red durante el envío del email\n   - Probar con direcciones de email inválidas o con formatos especiales\n   - Comprobar el comportamiento cuando Stripe envía el mismo evento múltiples veces\n\n4. Verificación manual:\n   - Recibir y verificar el email de activación en diferentes clientes de correo\n   - Comprobar que el enlace funciona correctamente en diferentes navegadores\n   - Verificar que la experiencia de usuario es clara y sin errores",
        "status": "in-progress",
        "dependencies": [
          25,
          27,
          28
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 31,
        "title": "[Testing] Implementar Pruebas de Integración para Flujo de Pago Anónimo",
        "description": "Desarrollar y ejecutar pruebas de integración completas para validar el flujo de pago anónimo en ambos escenarios (chat y propuesta pública), verificando el procesamiento correcto del webhook, la creación de cuentas y el envío de emails.",
        "details": "Esta tarea implica crear un conjunto completo de pruebas para validar el flujo de pago anónimo en ambos escenarios:\n\n1. Preparar el entorno de pruebas:\n   - Configurar un entorno de prueba aislado con Stripe en modo de prueba\n   - Crear datos de prueba para ambos escenarios (chat y propuesta pública)\n   - Configurar interceptores para capturar y verificar emails enviados\n\n2. Pruebas para el escenario de chat:\n   - Simular un pago anónimo a través del flujo de chat\n   - Verificar que el webhook procese correctamente el evento con `flujo_origen: 'chat'`\n   - Comprobar la creación correcta de la cuenta de usuario con `email_confirm: false`\n   - Validar que se envía el email de activación con el enlace correcto\n   - Verificar que el caso se vincula correctamente a la nueva cuenta\n\n3. Pruebas para el escenario de propuesta pública:\n   - Simular un pago anónimo a través del flujo de propuesta pública\n   - Verificar que el webhook procese correctamente el evento con `flujo_origen: 'propuesta_publica'`\n   - Comprobar la creación correcta de la cuenta de usuario\n   - Validar que se envía el email de activación\n   - Verificar que la propuesta se vincula correctamente a la nueva cuenta\n\n4. Pruebas para usuarios existentes:\n   - Simular pagos anónimos utilizando emails de usuarios ya existentes\n   - Verificar que no se crean cuentas duplicadas\n   - Comprobar que los casos/propuestas se vinculan a la cuenta existente\n   - Validar que no se envían emails de activación innecesarios\n\n5. Pruebas de escenarios de error:\n   - Simular fallos en la creación de cuentas\n   - Probar interrupciones en el proceso de pago\n   - Verificar el manejo de errores en el webhook\n\n6. Verificar que los flujos existentes de cobro del abogado no se ven afectados:\n   - Ejecutar pruebas de regresión en los flujos de cobro existentes\n   - Comprobar que no hay interferencias entre los diferentes flujos",
        "testStrategy": "1. Pruebas automatizadas:\n   - Desarrollar scripts de prueba que simulen pagos completos en Stripe (modo de prueba)\n   - Utilizar herramientas como Jest o Cypress para automatizar las pruebas de integración\n   - Implementar mocks para servicios externos cuando sea necesario\n\n2. Verificación del webhook:\n   - Utilizar Stripe CLI para simular eventos de webhook localmente\n   - Verificar en la base de datos que los eventos se procesan correctamente\n   - Comprobar los logs para confirmar el procesamiento adecuado según el `flujo_origen`\n\n3. Validación de creación de cuentas:\n   - Consultar la base de datos para verificar que las cuentas se crean con los atributos correctos\n   - Comprobar que no se crean cuentas duplicadas para emails existentes\n   - Verificar que el campo `email_confirm` se establece correctamente\n\n4. Verificación de emails:\n   - Configurar un servicio de captura de emails (como Mailhog o similar)\n   - Verificar que se envían los emails correctos con los enlaces de activación\n   - Comprobar el contenido y formato de los emails\n\n5. Pruebas de flujo completo:\n   - Seguir el proceso completo desde el pago hasta la activación de la cuenta\n   - Verificar que el usuario puede establecer su contraseña y acceder a su cuenta\n   - Comprobar que puede ver el caso o propuesta vinculada\n\n6. Pruebas de regresión:\n   - Ejecutar pruebas en los flujos de cobro existentes para abogados\n   - Verificar que no hay efectos secundarios en otras funcionalidades\n\n7. Documentación:\n   - Documentar todos los casos de prueba ejecutados\n   - Registrar los resultados y cualquier problema encontrado\n   - Crear un informe final de pruebas",
        "status": "pending",
        "dependencies": [
          27,
          28,
          30
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 32,
        "title": "Documentar Avances del Flujo de Pago Anónimo en SEPARACION_DASHBOARDS.md",
        "description": "Actualizar la documentación técnica en el archivo SEPARACION_DASHBOARDS.md para reflejar los avances implementados en el flujo de pago anónimo, incluyendo la nueva funcionalidad para propuestas públicas, modificaciones al webhook y mejoras en la creación de cuentas.",
        "details": "Esta tarea implica documentar de manera clara y detallada todos los cambios realizados en el flujo de pago anónimo:\n\n1. Revisar los cambios implementados en:\n   - La nueva función Edge para propuestas públicas (crear-sesion-checkout-propuesta-publica)\n   - Las modificaciones al webhook de Stripe para la creación de cuentas de usuarios anónimos\n   - El flujo completo de pago anónimo tanto para chat como para propuestas públicas\n\n2. Actualizar el archivo SEPARACION_DASHBOARDS.md con:\n   - Diagrama de flujo actualizado que muestre el proceso completo de pago anónimo en ambos escenarios\n   - Descripción detallada de cada componente del flujo y su interacción con otros sistemas\n   - Explicación de los cambios realizados en el webhook para garantizar la correcta creación de cuentas\n   - Documentación de la nueva función Edge para propuestas públicas\n   - Detalles sobre el manejo de emails de activación y el proceso de confirmación de cuenta\n\n3. Incluir información técnica relevante:\n   - Estructura de los metadatos utilizados en las sesiones de Stripe\n   - Campos importantes en la base de datos que se modifican durante el proceso\n   - Consideraciones de seguridad implementadas\n   - Posibles escenarios de error y cómo se manejan\n\n4. Mantener la consistencia con la documentación existente:\n   - Seguir el mismo formato y estilo del documento actual\n   - Asegurar que la nueva documentación se integre correctamente con las secciones existentes\n   - Actualizar cualquier referencia cruzada a otras partes de la documentación",
        "testStrategy": "1. Revisión de precisión técnica:\n   - Verificar que todos los flujos documentados corresponden exactamente a la implementación actual\n   - Confirmar que los diagramas representan con precisión el flujo de datos y las interacciones entre componentes\n   - Validar que todas las referencias a endpoints, funciones y tablas de la base de datos son correctas\n\n2. Revisión de completitud:\n   - Comprobar que se han documentado todos los aspectos del flujo de pago anónimo\n   - Verificar que se incluyen tanto el escenario de chat como el de propuestas públicas\n   - Confirmar que se documentan todos los posibles caminos de ejecución (casos de éxito y manejo de errores)\n\n3. Revisión por pares:\n   - Solicitar a otro desarrollador del equipo que revise la documentación\n   - Verificar que la documentación es comprensible para alguien que no ha trabajado directamente en la implementación\n   - Incorporar feedback y realizar ajustes necesarios\n\n4. Prueba de seguimiento de procesos:\n   - Utilizar la documentación para seguir manualmente el flujo completo y verificar que no hay pasos faltantes\n   - Intentar reproducir un escenario de pago anónimo siguiendo únicamente las instrucciones de la documentación",
        "status": "pending",
        "dependencies": [
          30,
          28,
          31,
          27
        ],
        "priority": "low",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-18T11:54:54.067Z",
      "updated": "2025-08-26T09:30:16.846Z",
      "description": "Tasks for master context"
    }
  }
}